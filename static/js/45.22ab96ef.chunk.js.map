{"version":3,"file":"static/js/45.22ab96ef.chunk.js","mappings":"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","sources":["babylon/multiMeshDecal.js"],"sourcesContent":["export async function createScene(engine, canvas, BABYLON) {\r\n  console.clear();\r\n  const scene = new BABYLON.Scene(engine);\r\n  scene.clearColor = new BABYLON.Color4(0.11, 0.11, 0.36);\r\n  scene.useRightHandedSystem = true;\r\n\r\n  var camera = new BABYLON.ArcRotateCamera(\"camera\", BABYLON.Tools.ToRadians(90), BABYLON.Tools.ToRadians(65), 10, BABYLON.Vector3.Zero(), scene);\r\n  camera.setTarget(new BABYLON.Vector3(1.14, 1.7, 0));\r\n  camera.alpha = 0.676;\r\n  camera.beta = 1.17;\r\n  camera.radius = 14;\r\n  camera.inertia = 0.4;\r\n  camera.wheelDeltaPercentage = 0.3;\r\n  camera.panningSensibility = 10000;\r\n  camera.minZ = 0.01;\r\n  camera.maxZ = 10000;\r\n  camera.attachControl(canvas, true);\r\n\r\n  var light = new BABYLON.HemisphericLight(\"light\", new BABYLON.Vector3(0, 1, 0), scene);\r\n  light.intensity = 0.7;\r\n\r\n  let isDecaling = true;\r\n  let decalCount = 0;\r\n  let decalAngle = 0;\r\n  let isDecalCanceled = false;\r\n  let isDrag = false;\r\n  let isDecalRotating = false;\r\n  let projector = null;\r\n  let decalScale = BABYLON.Vector3.One();\r\n  let decal = null;\r\n  let cullBackFaces = true;\r\n  let isDecalFin = false;\r\n  let isDecalHold = false;\r\n  let isMulitple = false;\r\n  let tempPickedMesh = null;\r\n  let decalMaterial = null;\r\n\r\n  const assets = {\r\n    manager: new BABYLON.AssetsManager(scene),\r\n  };\r\n\r\n  const meshes = {};\r\n  const decalsTex = [];\r\n\r\n  async function loadMeshes() {\r\n    // mesh task\r\n    assets.model = assets.manager.addMeshTask(\"model\", \"\", \"https://raw.githubusercontent.com/UN1TOne/3DAsset/master/\", \"metal_slug_tank.glb\");\r\n\r\n    // texture tasks\r\n    assets.decal1 = assets.manager.addTextureTask(\r\n      \"decal_logo\",\r\n      \"https://raw.githubusercontent.com/UN1TOne/3DAsset/master/Images/UNIT logo transparent.png\"\r\n    );\r\n\r\n    assets.manager.load();\r\n\r\n    // task error handling\r\n    assets.manager.onTaskErrorObservable.add((task) => {\r\n      console.log(\"Error loading task: \" + task.name);\r\n      console.log(task.errorObject.message, task.errorObject.exception);\r\n    });\r\n\r\n    // task success handling\r\n    assets.manager.onFinish = (tasks) => {\r\n      console.log(\"Finished loading tasks\", tasks);\r\n\r\n      meshes.root = assets.model.loadedMeshes[0];\r\n      meshes.root.scaling.scaleInPlace(100);\r\n      // meshes.root.normalizeToUnitCube = true;\r\n\r\n      decalsTex.push(assets.decal1.texture);\r\n\r\n      setDecal();\r\n    };\r\n  }\r\n  await loadMeshes();\r\n\r\n  const findGrandParent = (_node) => {\r\n    let upperRoot = null;\r\n\r\n    // if node has parent\r\n    if (!!_node && _node.parent != null) {\r\n      // Find the parent node by recursive\r\n      findGrandParent(_node.parent);\r\n    } else {\r\n      upperRoot = _node;\r\n    }\r\n    return upperRoot;\r\n  };\r\n\r\n  function setDecal() {\r\n    decalsTex[0].vAng = Math.PI;\r\n    const decalSize = BABYLON.Vector3.One().scaleInPlace(0.1);\r\n\r\n    const imgWidth = decalsTex[0].width ? decalsTex[0].width : 2048;\r\n    const imgHeight = decalsTex[0].height ? decalsTex[0].height : 2048;\r\n\r\n    projector = BABYLON.MeshBuilder.CreateBox(\r\n      \"decal_projector\",\r\n      { width: (decalSize.x * imgWidth) / 100, height: (decalSize.y * imgHeight) / 100, depth: decalSize.z * 10 }, // depth: decalSize.z * 3\r\n      // { width: 2, height: 2, depth: 2 }, // depth: decalSize.z * 3\r\n      scene\r\n    );\r\n\r\n    projector.position = BABYLON.Vector3.Zero();\r\n    projector.rotation = BABYLON.Vector3.Zero();\r\n    projector.scaling = BABYLON.Vector3.One();\r\n\r\n    projector.material = new BABYLON.PBRMaterial(\"projectorMat\", scene);\r\n    projector.material.alpha = 0;\r\n    projector.material.backFaceCulling = false;\r\n    projector.showBoundingBox = true;\r\n    projector.visibility = 1;\r\n\r\n    decalMaterial = new BABYLON.PBRMaterial(\"decalMat\" + decalCount, scene);\r\n    decalMaterial.albedoTexture = decalsTex[0];\r\n\r\n    decalMaterial.albedoTexture.hasAlpha = true;\r\n    decalMaterial.useAlphaFromAlbedoTexture = true;\r\n    decalMaterial.zOffset = -2;\r\n    decalMaterial.backFaceCulling = false;\r\n    decalMaterial.unlit = true;\r\n\r\n    let normal = null;\r\n    let sourceMeshes = [];\r\n\r\n    // Create decal on mesh\r\n    const createDecal = () => {\r\n      var pickInfo = scene.pick(scene.pointerX, scene.pointerY, (mesh) => mesh.isEnabled() && mesh !== projector);\r\n\r\n      if (pickInfo) {\r\n        if ((pickInfo.hit || isDecalHold) && projector) {\r\n          projector.visibility = 1;\r\n\r\n          if (decal) {\r\n            decal.dispose();\r\n            decal = null;\r\n          }\r\n\r\n          normal = scene.activeCamera.getForwardRay().direction.negateInPlace().normalize();\r\n\r\n          let position = BABYLON.Vector3.Zero();\r\n\r\n          pickInfo.pickedPoint && !isDecalHold ? (position = pickInfo.pickedPoint) : (position = projector.absolutePosition);\r\n\r\n          if (pickInfo.pickedMesh) {\r\n            tempPickedMesh = pickInfo.pickedMesh;\r\n          }\r\n          if (!isMulitple) {\r\n            if (pickInfo.pickedMesh) {\r\n              sourceMeshes = [];\r\n              sourceMeshes.push(pickInfo.pickedMesh);\r\n            } else {\r\n              sourceMeshes = [];\r\n              if (tempPickedMesh) sourceMeshes.push(tempPickedMesh);\r\n            }\r\n          } else {\r\n            for (const mesh of scene.meshes) {\r\n              if (mesh.isEnabled() && mesh !== projector) {\r\n                const intersects = mesh.intersectsMesh(projector);\r\n\r\n                if (intersects && !sourceMeshes.includes(mesh)) {\r\n                  sourceMeshes.push(mesh);\r\n                }\r\n                // if not intersected, splice that in sourceMeshes\r\n                else if (!intersects && sourceMeshes.includes(mesh)) {\r\n                  const index = sourceMeshes.indexOf(mesh);\r\n                  if (index > -1) {\r\n                    sourceMeshes.splice(index, 1);\r\n                  }\r\n                }\r\n              }\r\n            }\r\n          }\r\n\r\n          if (sourceMeshes.length > 0) {\r\n            if (pickInfo.pickedMesh || isDecalHold) {\r\n              // findGrandParent(pickInfo.pickedMesh);\r\n\r\n              for (const sourceMesh of sourceMeshes) {\r\n                findGrandParent(sourceMesh); // find root node for decal name\r\n\r\n                /* set decal name using count, asset name, sourceMesh name and root node name to identify where the decal stick to it.\r\n                                       To avoid overlapping because it keeps generated every time you move the mouse.\r\n                                    */\r\n                const decalNameRule = \"decal_\" + decalCount + \"_\" + assets.decal1.name + \"_\" + sourceMesh.name + \"_\";\r\n\r\n                const alreadyExistsDecal = scene.meshes.filter((e) => e.name === decalNameRule);\r\n\r\n                decal = BABYLON.MeshBuilder.CreateDecal(decalNameRule, sourceMesh, {\r\n                  position,\r\n                  normal,\r\n                  angle: decalAngle,\r\n                  size: new BABYLON.Vector3((imgWidth / 1000) * decalScale.x, (imgHeight / 1000) * decalScale.y, decalScale.z * 2),\r\n                  cullBackFaces,\r\n                  localMode: true,\r\n                });\r\n\r\n                if (decal.getTotalVertices() < 1 || !!!decal.subMeshes) decal.dispose();\r\n\r\n                decal.material = decalMaterial;\r\n                decal.alwaysSelectAsActiveMesh = true;\r\n                decal.material.metallic = 0;\r\n                decal.material.backFaceCulling = true;\r\n\r\n                if (alreadyExistsDecal.length > 0) {\r\n                  for (let i = 0; i < alreadyExistsDecal.length; i++) {\r\n                    alreadyExistsDecal[i].dispose();\r\n                    alreadyExistsDecal.splice(i, 1);\r\n                  }\r\n                  for (const existsdecal of alreadyExistsDecal) {\r\n                    existsdecal.dispose();\r\n                  }\r\n                }\r\n              }\r\n            }\r\n          }\r\n          const yaw = -Math.atan2(normal.z, normal.x) - Math.PI / 2;\r\n          const len = Math.sqrt(normal.x * normal.x + normal.z * normal.z);\r\n          const pitch = Math.atan2(normal.y, len);\r\n\r\n          if (!isDecalHold) {\r\n            projector.position.copyFrom(position);\r\n            projector.rotation.set(pitch, yaw, decalAngle);\r\n          }\r\n        } else {\r\n          if (decal) decal.visibility = 1;\r\n          projector.visibility = 1;\r\n        }\r\n\r\n        const tempDecal = scene.meshes.filter((e) => e.name.startsWith(\"decal_\"));\r\n        tempDecal.length > 0 &&\r\n          tempDecal.forEach((m) => {\r\n            if (!m.intersectsMesh(projector)) {\r\n              m.dispose();\r\n            }\r\n          });\r\n      }\r\n\r\n      setTimeout(() => {\r\n        isDecalRotating = false;\r\n      }, 1000);\r\n    };\r\n\r\n    var advancedTexture = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI(\"UI\");\r\n\r\n    var checkBoxPanel = new BABYLON.GUI.StackPanel();\r\n    checkBoxPanel.width = \"210px\";\r\n    checkBoxPanel.isVertical = false;\r\n    checkBoxPanel.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_RIGHT;\r\n    checkBoxPanel.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_CENTER;\r\n    advancedTexture.addControl(checkBoxPanel);\r\n\r\n    var checkbox = new BABYLON.GUI.Checkbox();\r\n    checkbox.width = \"20px\";\r\n    checkbox.height = \"20px\";\r\n    checkbox.isChecked = false;\r\n    checkbox.color = \"green\";\r\n    checkbox.onIsCheckedChangedObservable.add(function (value) {\r\n      isMulitple = !isMulitple;\r\n\r\n      scene.meshes.filter((m) => m.name.startsWith(\"decal_\") && m !== projector).forEach((m) => m.dispose());\r\n      decal?.dispose();\r\n\r\n      createDecal();\r\n    });\r\n    checkBoxPanel.addControl(checkbox);\r\n\r\n    var checkboxHeader = new BABYLON.GUI.TextBlock();\r\n    checkboxHeader.text = \" Use Multiple mode\";\r\n    checkboxHeader.width = \"180px\";\r\n    checkboxHeader.marginLeft = \"5px\";\r\n    checkboxHeader.textHorizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;\r\n    checkboxHeader.color = \"white\";\r\n    checkBoxPanel.addControl(checkboxHeader);\r\n\r\n    var optionPanel = new BABYLON.GUI.StackPanel();\r\n    optionPanel.width = \"220px\";\r\n    optionPanel.top = \"80px\";\r\n    optionPanel.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_RIGHT;\r\n    optionPanel.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_CENTER;\r\n    advancedTexture.addControl(optionPanel);\r\n\r\n    var sizeHeader = new BABYLON.GUI.TextBlock();\r\n    sizeHeader.text = \"Decal Size: 1\";\r\n    sizeHeader.height = \"30px\";\r\n    sizeHeader.color = \"white\";\r\n    optionPanel.addControl(sizeHeader);\r\n\r\n    var sizeSlider = new BABYLON.GUI.Slider();\r\n    sizeSlider.minimum = 0.1;\r\n    sizeSlider.maximum = 2;\r\n    sizeSlider.value = 1;\r\n    sizeSlider.step = 0.1;\r\n    sizeSlider.height = \"20px\";\r\n    sizeSlider.width = \"200px\";\r\n    sizeSlider.onValueChangedObservable.add(function (value) {\r\n      sizeHeader.text = \"Decal Size: \" + value.toFixed(1);\r\n      decalScale = new BABYLON.Vector3(value, value, value);\r\n      projector.scaling = new BABYLON.Vector3(value, value, value);\r\n\r\n      decal?.dispose();\r\n      createDecal();\r\n    });\r\n\r\n    optionPanel.addControl(sizeSlider);\r\n\r\n    var rotationHeader = new BABYLON.GUI.TextBlock();\r\n    rotationHeader.text = \"Decal Rotation: 0˚\";\r\n    rotationHeader.height = \"30px\";\r\n    rotationHeader.color = \"white\";\r\n    optionPanel.addControl(rotationHeader);\r\n\r\n    var rotationSlider = new BABYLON.GUI.Slider();\r\n    rotationSlider.minimum = 0;\r\n    rotationSlider.maximum = 2 * Math.PI;\r\n    rotationSlider.value = 0;\r\n    rotationSlider.step = 0.01;\r\n    rotationSlider.height = \"20px\";\r\n    rotationSlider.width = \"200px\";\r\n    rotationSlider.onValueChangedObservable.add(function (value) {\r\n      isDecalRotating = true;\r\n      decalAngle = value;\r\n      rotationHeader.text = \"Decal Rotation: \" + BABYLON.Tools.ToDegrees(value).toFixed(0) + \"˚\";\r\n\r\n      decal?.dispose();\r\n      createDecal();\r\n    });\r\n    optionPanel.addControl(rotationSlider);\r\n\r\n    const delay = 2;\r\n    let count = 0;\r\n\r\n    const decalObservable = scene.onBeforeRenderObservable.add(() => {\r\n      if (decal) {\r\n        decal.material.backFaceCulling = false;\r\n\r\n        if (!isDecaling) {\r\n          // when pressed the decal final ok button\r\n          isDecalFin = true;\r\n        }\r\n\r\n        if (isDecalFin || isDecalCanceled) {\r\n          if (isDecalCanceled) {\r\n            // if pressed the escape button\r\n            decal?.dispose(false, true);\r\n            scene.meshes.filter((e) => e.name.includes(\"decal_\" + decalCount + \"_\" + assets.decal1.name)).forEach((e) => e.dispose(false, true));\r\n          } else {\r\n            // normally finished the decal feature\r\n            const tempDecal = scene.meshes.filter((e) => e.name.startsWith(\"decal_\"));\r\n            tempDecal.length > 0 &&\r\n              tempDecal.forEach((m) => {\r\n                // if successfully sticked, replace the name with \"Decal_\" (temp decal disposing rule is finding the mesh whose name starts with \"decal_\")\r\n                m.name = m.name.replace(\"decal_\", \"Decal_\");\r\n\r\n                // Move slightly forward of the normals to make it clickable\r\n                const normals = m.getVerticesData(BABYLON.VertexBuffer.NormalKind);\r\n                if (normals) {\r\n                  const normalVector = new BABYLON.Vector3(normals[0], normals[1], normals[2]);\r\n                  const offsetDistance = 0.001;\r\n                  const newPosition = m.position.add(normalVector.scale(offsetDistance));\r\n                  m.position = newPosition;\r\n                }\r\n              });\r\n\r\n            if (decal.getTotalVertices() > 1 && decal?.subMeshes) {\r\n              const clonedDecal = decal.clone(decal.name);\r\n              clonedDecal.material.backFaceCulling = false;\r\n              clonedDecal.material.metallic = 0;\r\n            }\r\n            decal.dispose();\r\n          }\r\n\r\n          decalCount++;\r\n          if (projector) {\r\n            projector.position = BABYLON.Vector3.Zero();\r\n            projector.rotation = BABYLON.Vector3.Zero();\r\n            projector.scaling = BABYLON.Vector3.One();\r\n            projector.dispose(false, true);\r\n          }\r\n          decalAngle = 0;\r\n          decalsTex[0] = null;\r\n          scene.onPointerObservable.remove(decalDropObservable);\r\n          scene.onBeforeRenderObservable.remove(decalObservable);\r\n          isDecalCanceled = false;\r\n          isDecalFin = false;\r\n          isDecalHold = false;\r\n          isDecaling = false;\r\n          return;\r\n        } else {\r\n          if (isDecalRotating) {\r\n            createDecal();\r\n          }\r\n        }\r\n      }\r\n    });\r\n\r\n    const decalDropObservable = scene.onPointerObservable.add((evtData, evtState) => {\r\n      switch (evtData.type) {\r\n        case BABYLON.PointerEventTypes.POINTERDOWN:\r\n          if (evtData.event.button === 0) {\r\n            var holdPickInfo = scene.pick(scene.pointerX, scene.pointerY, (mesh) => mesh.name === \"decal_projector\");\r\n            if (holdPickInfo && holdPickInfo.pickedMesh) {\r\n              // release decal hold when clicking the decal projector\r\n              if (holdPickInfo.pickedMesh.name === \"decal_projector\") {\r\n                if (!isDrag && holdPickInfo.hit) isDecalHold = !isDecalHold;\r\n              }\r\n            }\r\n          }\r\n          break;\r\n        case BABYLON.PointerEventTypes.POINTERMOVE:\r\n          if (!isDecalHold) {\r\n            if (count === 0) {\r\n              createDecal();\r\n            }\r\n            count = (count + 1) % delay;\r\n          }\r\n          break;\r\n        default:\r\n          break;\r\n      }\r\n    });\r\n  }\r\n\r\n  var fileInput = document.createElement(\"input\");\r\n  fileInput.type = \"file\";\r\n  fileInput.accept = \"image\";\r\n  fileInput.style.display = \"none\";\r\n  document.body.appendChild(fileInput);\r\n\r\n  var advancedTexture_upload = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI(\"UploadButtonUI\");\r\n\r\n  var button = BABYLON.GUI.Button.CreateSimpleButton(\"uploadBtn\", \"Upload your Image\");\r\n  button.width = \"200px\";\r\n  button.height = \"40px\";\r\n  button.color = \"white\";\r\n  button.background = \"green\";\r\n  button.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_RIGHT;\r\n  button.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_BOTTOM;\r\n  button.onPointerClickObservable.add(() => {\r\n    fileInput.click();\r\n  });\r\n  advancedTexture_upload.addControl(button);\r\n\r\n  fileInput.addEventListener(\"change\", function (event) {\r\n    const file = event.target.files[0];\r\n    if (file) {\r\n      const blobUrl = URL.createObjectURL(file);\r\n      decalMaterial.albedoTexture = new BABYLON.Texture(blobUrl, scene);\r\n      decalMaterial.albedoTexture.hasAlpha = true;\r\n    }\r\n  });\r\n\r\n  return scene;\r\n}\r\n"],"names":["async","createScene","engine","canvas","BABYLON","console","clear","scene","Scene","clearColor","Color4","useRightHandedSystem","camera","ArcRotateCamera","Tools","ToRadians","Vector3","Zero","setTarget","alpha","beta","radius","inertia","wheelDeltaPercentage","panningSensibility","minZ","maxZ","attachControl","HemisphericLight","intensity","isDecaling","decalCount","decalAngle","isDecalCanceled","isDecalRotating","projector","decalScale","One","decal","cullBackFaces","isDecalFin","isDecalHold","isMulitple","tempPickedMesh","decalMaterial","assets","manager","AssetsManager","meshes","decalsTex","model","addMeshTask","decal1","addTextureTask","load","onTaskErrorObservable","add","task","log","name","errorObject","message","exception","onFinish","tasks","root","loadedMeshes","scaling","scaleInPlace","push","texture","vAng","Math","PI","decalSize","imgWidth","width","imgHeight","height","MeshBuilder","CreateBox","x","y","depth","z","position","rotation","material","PBRMaterial","backFaceCulling","showBoundingBox","visibility","albedoTexture","hasAlpha","useAlphaFromAlbedoTexture","zOffset","unlit","normal","sourceMeshes","createDecal","pickInfo","pick","pointerX","pointerY","mesh","isEnabled","hit","dispose","activeCamera","getForwardRay","direction","negateInPlace","normalize","pickedPoint","absolutePosition","pickedMesh","intersects","intersectsMesh","includes","index","indexOf","splice","length","sourceMesh","findGrandParent","decalNameRule","alreadyExistsDecal","filter","e","CreateDecal","angle","size","localMode","getTotalVertices","subMeshes","alwaysSelectAsActiveMesh","metallic","i","existsdecal","yaw","atan2","len","sqrt","pitch","copyFrom","set","tempDecal","startsWith","forEach","m","setTimeout","advancedTexture","GUI","AdvancedDynamicTexture","CreateFullscreenUI","checkBoxPanel","StackPanel","isVertical","horizontalAlignment","Control","HORIZONTAL_ALIGNMENT_RIGHT","verticalAlignment","VERTICAL_ALIGNMENT_CENTER","addControl","checkbox","Checkbox","isChecked","color","onIsCheckedChangedObservable","value","_decal","checkboxHeader","TextBlock","text","marginLeft","textHorizontalAlignment","HORIZONTAL_ALIGNMENT_LEFT","optionPanel","top","sizeHeader","sizeSlider","Slider","minimum","maximum","step","onValueChangedObservable","_decal2","toFixed","rotationHeader","rotationSlider","_decal3","ToDegrees","delay","count","decalObservable","onBeforeRenderObservable","_decal4","_decal5","replace","normals","getVerticesData","VertexBuffer","NormalKind","normalVector","offsetDistance","newPosition","scale","clonedDecal","clone","onPointerObservable","remove","decalDropObservable","evtData","evtState","type","PointerEventTypes","POINTERDOWN","event","button","holdPickInfo","POINTERMOVE","setDecal","loadMeshes","_node","upperRoot","parent","fileInput","document","createElement","accept","style","display","body","appendChild","advancedTexture_upload","Button","CreateSimpleButton","background","VERTICAL_ALIGNMENT_BOTTOM","onPointerClickObservable","click","addEventListener","file","target","files","blobUrl","URL","createObjectURL","Texture"],"sourceRoot":""}