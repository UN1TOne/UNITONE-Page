{"version":3,"file":"static/js/155.d1dae63a.chunk.js","mappings":"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","sources":["babylon/imageParticleMorph.js"],"sourcesContent":["export async function createScene(engine, canvas, BABYLON) {\r\n  const scene = new BABYLON.Scene(engine);\r\n  scene.clearColor = new BABYLON.Color4(0, 0, 0, 1);\r\n  scene.useRightHandedSystem = true;\r\n\r\n  const camera = new BABYLON.ArcRotateCamera(\"Camera\", Math.PI / 2, Math.PI / 2, 30, BABYLON.Vector3.Zero(), scene);\r\n  camera.attachControl(canvas, true);\r\n\r\n  const light = new BABYLON.HemisphericLight(\"light\", new BABYLON.Vector3(0, 1, 0), scene);\r\n\r\n  // Options\r\n  const options = {\r\n    dotSize: 7,\r\n    density: 10,\r\n    resolution: 256,\r\n    nerve: 0,\r\n    twitchDist: 5,\r\n    amount: 10000,\r\n  };\r\n\r\n  // Image URLs (using placeholder images that allow CORS)\r\n  let images = [\r\n    \"https://raw.githubusercontent.com/UN1TOne/3DAsset/master/Images/UNIQUE.png\",\r\n    \"https://raw.githubusercontent.com/UN1TOne/3DAsset/master/Images/NEW IDEAS.png\",\r\n    \"https://raw.githubusercontent.com/UN1TOne/3DAsset/master/Images/INNOVATION.png\",\r\n    \"https://raw.githubusercontent.com/UN1TOne/3DAsset/master/Images/TECH.png\",\r\n  ];\r\n\r\n  const advancedTexture = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI(\"UI\");\r\n\r\n  let currentImage = 0;\r\n  let galleryData = [];\r\n\r\n  // Utility functions (unchanged)\r\n  function fillUp(array, max) {\r\n    if (array.length > max) {\r\n      while (array.length > max) {\r\n        array.splice(Math.floor(Math.random() * array.length), 1);\r\n      }\r\n    } else {\r\n      while (array.length < max) {\r\n        array.push(array[Math.floor(Math.random() * array.length)]);\r\n      }\r\n    }\r\n    return array;\r\n  }\r\n\r\n  function shuffle(a) {\r\n    for (let i = a.length - 1; i > 0; i--) {\r\n      const j = Math.floor(Math.random() * (i + 1));\r\n      [a[i], a[j]] = [a[j], a[i]];\r\n    }\r\n    return a;\r\n  }\r\n\r\n  function getArrayFromImage(img, options) {\r\n    const canvas = document.createElement(\"canvas\");\r\n    const ctx = canvas.getContext(\"2d\");\r\n    if (!ctx) throw new Error(\"Could not get 2D context\");\r\n\r\n    canvas.width = options.resolution;\r\n    canvas.height = options.resolution;\r\n\r\n    const hRatio = canvas.width / img.width;\r\n    const vRatio = canvas.height / img.height;\r\n    const ratio = Math.min(hRatio, vRatio);\r\n    const centerShift_x = (canvas.width - img.width * ratio) / 2;\r\n    const centerShift_y = (canvas.height - img.height * ratio) / 2;\r\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\r\n    ctx.drawImage(img, 0, 0, img.width, img.height, centerShift_x, centerShift_y, img.width * ratio, img.height * ratio);\r\n\r\n    let imageCoords = [];\r\n\r\n    try {\r\n      const imageData = ctx.getImageData(0, 0, options.resolution, options.resolution);\r\n      const data = imageData.data;\r\n\r\n      for (let y = 0; y < options.resolution; y++) {\r\n        for (let x = 0; x < options.resolution; x++) {\r\n          const index = (y * options.resolution + x) * 4;\r\n          const red = data[index];\r\n          const green = data[index + 1];\r\n          const blue = data[index + 2];\r\n          const alpha = data[index + 3];\r\n          if (alpha > 0) {\r\n            imageCoords.push({\r\n              x: options.density * (x - options.resolution / 2),\r\n              y: options.density * (options.resolution / 2 - y),\r\n              red: red,\r\n              green: green,\r\n              blue: blue,\r\n            });\r\n          }\r\n        }\r\n      }\r\n    } catch (error) {\r\n      console.error(\"Error processing image data:\", error);\r\n      // Fallback: create random coordinates if image processing fails\r\n      for (let i = 0; i < options.amount; i++) {\r\n        imageCoords.push({\r\n          x: (Math.random() - 0.5) * options.resolution * options.density,\r\n          y: (Math.random() - 0.5) * options.resolution * options.density,\r\n          red: Math.random() * 255,\r\n          green: Math.random() * 255,\r\n          blue: Math.random() * 255,\r\n        });\r\n      }\r\n    }\r\n\r\n    return shuffle(fillUp(imageCoords, options.amount));\r\n  }\r\n\r\n  // Load images and create particle system\r\n  const loadImages = async () => {\r\n    const loadedImages = await Promise.all(\r\n      images.map((src) => {\r\n        return new Promise((resolve, reject) => {\r\n          const img = new Image();\r\n          img.crossOrigin = \"anonymous\"; // This line is crucial for CORS\r\n          img.onload = () => resolve(img);\r\n          img.onerror = reject;\r\n          img.src = src;\r\n        });\r\n      })\r\n    );\r\n\r\n    galleryData = loadedImages.map((img) => getArrayFromImage(img, options));\r\n\r\n    const particleSystem = new BABYLON.ParticleSystem(\"particles\", options.amount, scene);\r\n    particleSystem.particleTexture = new BABYLON.Texture(\"https://assets.babylonjs.com/textures/particle.png\", scene);\r\n    particleSystem.particleTexture.hasAlpha = true;\r\n\r\n    particleSystem.minSize = 0.2;\r\n    particleSystem.maxSize = 0.3;\r\n    particleSystem.manualEmitCount = 2500;\r\n\r\n    particleSystem.startPositionFunction = (worldMatrix, positionToUpdate) => {\r\n      const index = particleSystem.particles.length;\r\n      const data = galleryData[currentImage][index];\r\n      positionToUpdate.x = data.x / 100;\r\n      positionToUpdate.y = data.y / 100;\r\n      positionToUpdate.z = 0;\r\n    };\r\n\r\n    particleSystem.updateFunction = (particles) => {\r\n      for (let i = 0; i < particles.length; i++) {\r\n        const particle = particles[i];\r\n        const data = galleryData[currentImage][i];\r\n        particle.position.x += (data.x / 100 - particle.position.x) * 0.1 + (Math.random() - 0.5) * 0.05;\r\n        particle.position.y += (data.y / 100 - particle.position.y) * 0.1 + (Math.random() - 0.5) * 0.05;\r\n        particle.color = new BABYLON.Color4(data.red / 255, data.green / 255, data.blue / 255, 1);\r\n      }\r\n    };\r\n\r\n    particleSystem.start();\r\n\r\n    // Add button for next image\r\n    const button = BABYLON.GUI.Button.CreateSimpleButton(\"nextImage\", \"Next Image\");\r\n    button.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_BOTTOM;\r\n    button.width = \"150px\";\r\n    button.height = \"40px\";\r\n    button.top = \"-50px\";\r\n    button.color = \"white\";\r\n    button.cornerRadius = 20;\r\n    button.background = \"green\";\r\n    button.onPointerUpObservable.add(() => {\r\n      currentImage = (currentImage + 1) % images.length;\r\n    });\r\n    advancedTexture.addControl(button);\r\n  };\r\n\r\n  loadImages();\r\n\r\n  return scene;\r\n}\r\n"],"names":["async","createScene","engine","canvas","BABYLON","scene","Scene","clearColor","Color4","useRightHandedSystem","ArcRotateCamera","Math","PI","Vector3","Zero","attachControl","HemisphericLight","options","dotSize","density","resolution","nerve","twitchDist","amount","images","advancedTexture","GUI","AdvancedDynamicTexture","CreateFullscreenUI","currentImage","galleryData","getArrayFromImage","img","document","createElement","ctx","getContext","Error","width","height","hRatio","vRatio","ratio","min","centerShift_x","centerShift_y","clearRect","drawImage","imageCoords","data","getImageData","y","x","index","red","green","blue","push","error","console","i","random","a","length","j","floor","shuffle","array","max","splice","fillUp","loadedImages","Promise","all","map","src","resolve","reject","Image","crossOrigin","onload","onerror","particleSystem","ParticleSystem","particleTexture","Texture","hasAlpha","minSize","maxSize","manualEmitCount","startPositionFunction","worldMatrix","positionToUpdate","particles","z","updateFunction","particle","position","color","start","button","Button","CreateSimpleButton","verticalAlignment","Control","VERTICAL_ALIGNMENT_BOTTOM","top","cornerRadius","background","onPointerUpObservable","add","addControl","loadImages"],"sourceRoot":""}