{"version":3,"file":"static/js/838.4a2fb748.chunk.js","mappings":"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","sources":["babylon/gridInteraction.js"],"sourcesContent":["export async function createScene(engine, canvas, BABYLON) {\r\n  var scene = new BABYLON.Scene(engine);\r\n\r\n  var light = new BABYLON.HemisphericLight(\"light\", new BABYLON.Vector3(0, 1, 0), scene);\r\n  light.intensity = 0.7;\r\n\r\n  scene.clearColor = new BABYLON.Color4(0.1, 0.1, 0.12, 1);\r\n\r\n  const camera = new BABYLON.ArcRotateCamera(\"camera\", -0.989, 0.553, 20, new BABYLON.Vector3(0, 0, 0), scene);\r\n  camera.attachControl();\r\n\r\n  BABYLON.Effect.ShadersStore[\"GridVertexShader\"] = `\r\n        precision highp float;\r\n        attribute vec3 position;\r\n        attribute vec3 normal;\r\n        attribute vec2 uv;\r\n        uniform mat4 worldViewProjection;\r\n        varying vec3 vPosition;\r\n        varying vec3 vNormal;\r\n        varying vec2 vUV;\r\n        void main() {\r\n            gl_Position = worldViewProjection * vec4(position, 1.0);\r\n            vPosition = position;\r\n            vNormal = normalize(normal);\r\n            vUV = uv;\r\n        }\r\n    `;\r\n\r\n  BABYLON.Effect.ShadersStore[\"GridFragmentShader\"] = `\r\n        precision highp float;\r\n        varying vec3 vPosition;\r\n        varying vec3 vNormal;\r\n        varying vec2 vUV;\r\n        uniform vec3 color;\r\n        uniform float opacity;\r\n        void main() {\r\n            vec2 grid = abs(fract(vUV * 10.0 - 0.5) - 0.5) / fwidth(vUV * 10.0);\r\n            float line = min(grid.x, grid.y);\r\n            float alpha = step(1.0, line);\r\n            gl_FragColor = vec4(color, opacity * (1.0 - alpha));\r\n        }\r\n    `;\r\n\r\n  const createGridMaterial = (scene, color) => {\r\n    const material = new BABYLON.ShaderMaterial(\"Grid\", scene, \"Grid\", {\r\n      attributes: [\"position\", \"normal\", \"uv\"],\r\n      uniforms: [\"worldViewProjection\", \"color\", \"opacity\"],\r\n    });\r\n\r\n    material.setColor3(\"color\", color);\r\n    material.setFloat(\"opacity\", 1.0);\r\n\r\n    return material;\r\n  };\r\n\r\n  const gridSize = 8;\r\n  const tileSize = 1;\r\n  const spacing = 1.2;\r\n  const startX = -(gridSize * spacing) / 2;\r\n  const startZ = -(gridSize * spacing) / 2;\r\n\r\n  const defaultColor = new BABYLON.Color3(0.8, 0.6, 0.2);\r\n  const hoverColor = new BABYLON.Color3(1, 0.93, 0.15);\r\n\r\n  const tiles = [];\r\n\r\n  for (let x = 0; x < gridSize; x++) {\r\n    tiles[x] = [];\r\n    for (let z = 0; z < gridSize; z++) {\r\n      const tile = BABYLON.MeshBuilder.CreateBox(`tile-${x}-${z}`, { width: tileSize, height: 0.1, depth: tileSize }, scene);\r\n\r\n      tile.position.x = startX + x * spacing;\r\n      tile.position.z = startZ + z * spacing;\r\n      tile.position.y = 0;\r\n\r\n      const material = createGridMaterial(scene, defaultColor);\r\n      tile.material = material;\r\n\r\n      tiles[x][z] = tile;\r\n\r\n      tile.actionManager = new BABYLON.ActionManager(scene);\r\n\r\n      tile.actionManager.registerAction(\r\n        new BABYLON.ExecuteCodeAction(BABYLON.ActionManager.OnPointerOverTrigger, () => {\r\n          BABYLON.Animation.CreateAndStartAnimation(\r\n            \"tileHover\",\r\n            tile,\r\n            \"position.y\",\r\n            60,\r\n            10,\r\n            tile.position.y,\r\n            0.3,\r\n            BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT\r\n          );\r\n\r\n          BABYLON.Animation.CreateAndStartAnimation(\r\n            \"tileHoverFlip\",\r\n            tile,\r\n            \"rotation.x\",\r\n            60,\r\n            10,\r\n            tile.rotation.x,\r\n            Math.PI,\r\n            BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT\r\n          );\r\n\r\n          tile.material.setColor3(\"color\", hoverColor);\r\n        })\r\n      );\r\n\r\n      tile.actionManager.registerAction(\r\n        new BABYLON.ExecuteCodeAction(BABYLON.ActionManager.OnPointerOutTrigger, () => {\r\n          BABYLON.Animation.CreateAndStartAnimation(\r\n            \"tileReset\",\r\n            tile,\r\n            \"position.y\",\r\n            60,\r\n            10,\r\n            tile.position.y,\r\n            0,\r\n            BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT\r\n          );\r\n\r\n          BABYLON.Animation.CreateAndStartAnimation(\r\n            \"tileHoverFlip\",\r\n            tile,\r\n            \"rotation.x\",\r\n            60,\r\n            10,\r\n            tile.rotation.x,\r\n            0,\r\n            BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT\r\n          );\r\n          tile.material.setColor3(\"color\", defaultColor);\r\n        })\r\n      );\r\n    }\r\n  }\r\n\r\n  scene.onPointerMove = () => {\r\n    const pick = scene.pick(scene.pointerX, scene.pointerY);\r\n    if (pick.hit) {\r\n      const hitPoint = pick.pickedPoint;\r\n      tiles.forEach((row) => {\r\n        row.forEach((tile) => {\r\n          const dx = tile.position.x - hitPoint.x;\r\n          const dz = tile.position.z - hitPoint.z;\r\n          const distance = Math.sqrt(dx * dx + dz * dz);\r\n          const maxDistance = 3;\r\n\r\n          // 거리 기반 목표 높이 계산\r\n          const targetHeight = distance < maxDistance ? (1 - distance / maxDistance) * 0.5 : 0;\r\n\r\n          // 목표 높이가 변경되었을 때만 애니메이션 실행\r\n          if (Math.abs(tile.targetHeight - targetHeight) > 0.01) {\r\n            // tile.targetHeight = targetHeight;\r\n\r\n            BABYLON.Animation.CreateAndStartAnimation(\r\n              \"tileMove\",\r\n              tile,\r\n              \"position.y\",\r\n              60,\r\n              10,\r\n              tile.position.y,\r\n              tile.position.y + 0.2,\r\n              BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT\r\n            );\r\n\r\n            BABYLON.Animation.CreateAndStartAnimation(\r\n              \"tileMoveFlip\",\r\n              tile,\r\n              \"rotation.x\",\r\n              60,\r\n              10,\r\n              tile.rotation.x,\r\n              tile.rotation.x + Math.PI / 2,\r\n              BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT\r\n            );\r\n          }\r\n        });\r\n      });\r\n    }\r\n  };\r\n\r\n  return scene;\r\n}\r\n"],"names":["async","createScene","engine","canvas","BABYLON","scene","Scene","HemisphericLight","Vector3","intensity","clearColor","Color4","ArcRotateCamera","attachControl","Effect","ShadersStore","createGridMaterial","color","material","ShaderMaterial","attributes","uniforms","setColor3","setFloat","spacing","defaultColor","Color3","hoverColor","tiles","x","z","tile","MeshBuilder","CreateBox","width","height","depth","position","y","actionManager","ActionManager","registerAction","ExecuteCodeAction","OnPointerOverTrigger","Animation","CreateAndStartAnimation","ANIMATIONLOOPMODE_CONSTANT","rotation","Math","PI","OnPointerOutTrigger","onPointerMove","pick","pointerX","pointerY","hit","hitPoint","pickedPoint","forEach","row","dx","dz","distance","sqrt","targetHeight","abs"],"sourceRoot":""}