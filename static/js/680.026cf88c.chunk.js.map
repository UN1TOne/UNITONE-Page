{"version":3,"file":"static/js/680.026cf88c.chunk.js","mappings":"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","sources":["babylon/heartPulseShader.js"],"sourcesContent":["export async function createScene(engine, canvas, BABYLON) {\r\n  console.clear();\r\n  const scene = new BABYLON.Scene(engine);\r\n  scene.clearColor = BABYLON.Color4.FromHexString(\"#8B3939FF\");\r\n  scene.useRightHandedSystem = true;\r\n\r\n  var camera = new BABYLON.ArcRotateCamera(\"camera\", BABYLON.Tools.ToRadians(90), BABYLON.Tools.ToRadians(65), 10, BABYLON.Vector3.Zero(), scene);\r\n  camera.setTarget(new BABYLON.Vector3(0.07, 1.14, 0.06));\r\n  camera.alpha = 1.628;\r\n  camera.beta = 1.4;\r\n  camera.radius = 1.6;\r\n  camera.inertia = 0.4;\r\n  camera.wheelDeltaPercentage = 0.3;\r\n  camera.panningSensibility = 10000;\r\n  camera.minZ = 0.01;\r\n  camera.maxZ = 10000;\r\n  camera.attachControl(canvas, true);\r\n\r\n  var hemiLight = new BABYLON.HemisphericLight(\"light\", new BABYLON.Vector3(-0.18, 0.29, 0.93), scene);\r\n  let hemiIntensity = 5;\r\n  hemiLight.intensity = hemiIntensity;\r\n\r\n  var dirLight = new BABYLON.DirectionalLight(\"DirLight\", new BABYLON.Vector3(0.17, -0.35, -0.91), scene);\r\n  dirLight.position = new BABYLON.Vector3(1, 1, 0.5);\r\n\r\n  var fileInput = document.createElement(\"input\");\r\n  fileInput.type = \"file\";\r\n  fileInput.accept = \".glb\";\r\n  fileInput.style.display = \"none\";\r\n  document.body.appendChild(fileInput);\r\n\r\n  let rootMesh;\r\n  let originalMaterial, shaderMaterial;\r\n  let isPBR = true;\r\n\r\n  BABYLON.SceneLoader.ImportMeshAsync(\"\", \"https://raw.githubusercontent.com/UN1TOne/3DAsset/master/\", \"human_heart.glb\").then((result) => {\r\n    rootMesh = result.meshes[0];\r\n    rootMesh.normalizeToUnitCube(true);\r\n\r\n    const heartMesh = rootMesh.getChildMeshes(false)[0];\r\n    originalMaterial = heartMesh.material;\r\n\r\n    camera.setTarget(heartMesh);\r\n    camera.alpha = 1.628;\r\n    camera.beta = 1.4;\r\n    camera.radius = 1.6;\r\n\r\n    BABYLON.Effect.ShadersStore[\"customPBRVertexShader\"] = `\r\n            precision highp float;\r\n\r\n            attribute vec3 position;\r\n            attribute vec3 normal;\r\n            attribute vec2 uv;\r\n\r\n            uniform mat4 worldViewProjection;\r\n            uniform mat4 world;\r\n            uniform float time;\r\n\r\n            varying vec3 vPosition;\r\n            varying vec3 vNormal;\r\n            varying vec2 vUV;\r\n\r\n            void main() {\r\n                float pulse = sin(time * 3.0) * 0.05;\r\n                vec3 newPosition = position + normal * pulse;\r\n\r\n                gl_Position = worldViewProjection * vec4(newPosition, 1.0);\r\n                vPosition = vec3(world * vec4(position, 1.0));\r\n                vNormal = normalize(vec3(world * vec4(normal, 0.0)));\r\n                vUV = uv;\r\n            }\r\n        `;\r\n\r\n    BABYLON.Effect.ShadersStore[\"customPBRFragmentShader\"] = `\r\n    precision highp float;\r\n\r\n    varying vec3 vPosition;\r\n    varying vec3 vNormal;\r\n    varying vec2 vUV;\r\n\r\n    uniform vec3 lightPosition;\r\n    uniform vec3 lightDirection;\r\n    uniform vec3 hemiDirection; \r\n    uniform float hemiIntensity;\r\n    uniform vec3 cameraPosition;\r\n    uniform sampler2D albedoTexture;\r\n    uniform sampler2D metallicRoughnessTexture;\r\n    uniform sampler2D bumpTexture;\r\n    uniform float metallic;\r\n    uniform float roughness;\r\n\r\n    const float PI = 3.14159265359;\r\n\r\n    // Normal Distribution Function (Trowbridge-Reitz GGX)\r\n    float D_GGX(float NoH, float roughness) {\r\n        float a = roughness * roughness;\r\n        float a2 = a * a;\r\n        float NoH2 = NoH * NoH;\r\n        float denom = NoH2 * (a2 - 1.0) + 1.0;\r\n        return a2 / (PI * denom * denom);\r\n    }\r\n\r\n    // Geometry Function (Schlick-GGX)\r\n    float G_SchlickGGX(float NoV, float roughness) {\r\n        float r = roughness + 1.0;\r\n        float k = (r * r) / 8.0;\r\n        return NoV / (NoV * (1.0 - k) + k);\r\n    }\r\n\r\n    // Fresnel (Schlick 근사)\r\n    vec3 F_Schlick(float VoH, vec3 F0) {\r\n        return F0 + (1.0 - F0) * pow(1.0 - VoH, 5.0);\r\n    }\r\n\r\n    // Bump 매핑으로 법선 계산\r\n    vec3 perturbNormal(vec3 normal, vec3 bump, vec2 uv) {\r\n        vec3 tangentNormal = bump * 2.0 - 1.0;\r\n        vec3 dPx = dFdx(vPosition);\r\n        vec3 dPy = dFdy(vPosition);\r\n        vec2 dUVx = dFdx(uv);\r\n        vec2 dUVy = dFdy(uv);\r\n\r\n        vec3 T = normalize(dPx * dUVy.t - dPy * dUVx.t);\r\n        vec3 B = normalize(cross(normal, T));\r\n        mat3 TBN = mat3(T, B, normal);\r\n\r\n        return normalize(TBN * tangentNormal);\r\n    }\r\n\r\n    void main() {\r\n        // 텍스처 샘플링\r\n        vec3 albedo = texture2D(albedoTexture, vUV).rgb;\r\n        vec3 metallicRoughness = texture2D(metallicRoughnessTexture, vUV).rgb;\r\n        vec3 bump = texture2D(bumpTexture, vUV).rgb;\r\n\r\n        // 텍스처 값과 유니폼 값을 조합\r\n        float texMetallic = metallicRoughness.b;\r\n        float texRoughness = metallicRoughness.g;\r\n        float finalMetallic = (metallic < 0.0) ? texMetallic : metallic;\r\n        float finalRoughness = (roughness < 0.0) ? texRoughness : roughness;\r\n\r\n        // Bump 매핑으로 법선 조정\r\n        vec3 N = perturbNormal(normalize(vNormal), bump, vUV);\r\n        vec3 V = normalize(cameraPosition - vPosition);\r\n\r\n        // 1. 점 광원 또는 방향성 광원 계산\r\n        vec3 L;\r\n        float NoL;\r\n        if (length(lightDirection) > 0.0) {\r\n            L = normalize(-lightDirection); // 방향성 광원\r\n            NoL = max(dot(N, L), 0.0);\r\n        } else {\r\n            L = normalize(lightPosition - vPosition); // 점 광원\r\n            NoL = max(dot(N, L), 0.0);\r\n        }\r\n\r\n        vec3 H = normalize(V + L);\r\n        float NoV = max(dot(N, V), 0.0);\r\n        float NoH = max(dot(N, H), 0.0);\r\n        float VoH = max(dot(V, H), 0.0);\r\n\r\n        // F0 계산\r\n        vec3 F0 = mix(vec3(0.04), albedo, finalMetallic);\r\n\r\n        // Cook-Torrance BRDF (Specular)\r\n        float NDF = D_GGX(NoH, finalRoughness);\r\n        float G = G_SchlickGGX(NoV, finalRoughness) * G_SchlickGGX(NoL, finalRoughness);\r\n        vec3 F = F_Schlick(VoH, F0);\r\n        vec3 specular = (NDF * G * F) / (4.0 * NoV * NoL + 0.001);\r\n\r\n        // Diffuse (기존 광원)\r\n        vec3 kS = F;\r\n        vec3 kD = vec3(1.0) - kS;\r\n        kD *= 1.0 - finalMetallic;\r\n        vec3 diffuse = kD * albedo / PI;\r\n\r\n        // 2. HemisphericLight 계산\r\n        vec3 hemiL = normalize(hemiDirection);\r\n        float hemiNoL = max(dot(N, hemiL), 0.0); // 반구광 방향과 법선의 각도\r\n        vec3 hemiColor = vec3(1.0) * hemiIntensity; // 세기를 반영한 반구광 색상\r\n        vec3 hemiDiffuse = kD * albedo / PI * hemiNoL * hemiIntensity; // 반구광 기여도\r\n\r\n        // 최종 색상 합산\r\n        vec3 lightColor = vec3(1.0); // 기본 광원 색상\r\n        vec3 radiance = lightColor * NoL; // 점/방향성 광원의 radiance\r\n        vec3 color = (diffuse + specular) * radiance + hemiDiffuse; // 반구광 추가\r\n\r\n        // 감마 보정\r\n        color = pow(color, vec3(1.0 / 2.2));\r\n\r\n        gl_FragColor = vec4(color, 1.0);\r\n    }\r\n`;\r\n\r\n    shaderMaterial = new BABYLON.ShaderMaterial(\r\n      \"pbrShader\",\r\n      scene,\r\n      {\r\n        vertex: \"customPBR\",\r\n        fragment: \"customPBR\",\r\n      },\r\n      {\r\n        attributes: [\"position\", \"normal\", \"uv\"],\r\n        uniforms: [\r\n          \"worldViewProjection\",\r\n          \"world\",\r\n          \"view\",\r\n          \"projection\",\r\n          \"lightPosition\",\r\n          \"lightDirection\",\r\n          \"hemiDirection\",\r\n          \"hemiIntensity\",\r\n          \"cameraPosition\",\r\n          \"time\",\r\n          \"metallic\",\r\n          \"roughness\",\r\n        ],\r\n        samplers: [\"albedoTexture\", \"metallicRoughnessTexture\", \"bumpTexture\"],\r\n      }\r\n    );\r\n\r\n    shaderMaterial.setTexture(\"albedoTexture\", heartMesh.material.albedoTexture);\r\n    shaderMaterial.setTexture(\"metallicRoughnessTexture\", heartMesh.material.metallicTexture);\r\n    shaderMaterial.setTexture(\"bumpTexture\", heartMesh.material.bumpTexture);\r\n\r\n    shaderMaterial.setFloat(\"metallic\", 0.07);\r\n    shaderMaterial.setFloat(\"roughness\", 0.18);\r\n    // shaderMaterial.setFloat(\"metallic\", 0.19);\r\n    // shaderMaterial.setFloat(\"roughness\", 0.33);\r\n\r\n    dirLight.direction = new BABYLON.Vector3(0.17, -0.35, -0.91);\r\n\r\n    scene.registerBeforeRender(() => {\r\n      shaderMaterial.setFloat(\"time\", performance.now() * 0.001);\r\n      shaderMaterial.setVector3(\"cameraPosition\", scene.activeCamera.position);\r\n      shaderMaterial.setVector3(\"lightPosition\", dirLight.position);\r\n      shaderMaterial.setVector3(\"lightDirection\", dirLight.direction);\r\n      shaderMaterial.setVector3(\"hemiDirection\", hemiLight.direction);\r\n      shaderMaterial.setFloat(\"hemiIntensity\", hemiLight.intensity);\r\n    });\r\n\r\n    shaderMaterial.addUniformsToInspector([\r\n      {\r\n        label: \"Metallic\",\r\n        propertyName: \"metallic\",\r\n        type: BABYLON.InspectableType.Slider,\r\n        min: 0.0,\r\n        max: 1.0,\r\n        step: 0.01,\r\n      },\r\n      {\r\n        label: \"Roughness\",\r\n        propertyName: \"roughness\",\r\n        type: BABYLON.InspectableType.Slider,\r\n        min: 0.0,\r\n        max: 1.0,\r\n        step: 0.01,\r\n      },\r\n    ]);\r\n\r\n    heartMesh.material = shaderMaterial;\r\n\r\n    heartMesh.inspectableCustomProperties = camera.inspectableCustomProperties || [];\r\n    heartMesh.inspectableCustomProperties.push({\r\n      label: \"Original PBRMaterial\",\r\n      type: BABYLON.InspectableType.Button,\r\n      callback() {\r\n        if (isPBR) {\r\n          heartMesh.material = originalMaterial;\r\n          hemiLight.intensity = 1;\r\n        } else {\r\n          heartMesh.material = shaderMaterial;\r\n          hemiLight.intensity = hemiIntensity;\r\n        }\r\n\r\n        isPBR = !isPBR;\r\n      },\r\n    });\r\n\r\n    var advancedTexture = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI(\"UI\");\r\n\r\n    var panel = new BABYLON.GUI.StackPanel();\r\n    panel.width = \"200px\";\r\n    panel.isVertical = false;\r\n    panel.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_RIGHT;\r\n    panel.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_CENTER;\r\n    advancedTexture.addControl(panel);\r\n\r\n    var checkbox = new BABYLON.GUI.Checkbox();\r\n    checkbox.width = \"20px\";\r\n    checkbox.height = \"20px\";\r\n    checkbox.isChecked = isPBR;\r\n    checkbox.color = \"green\";\r\n    checkbox.onIsCheckedChangedObservable.add(function (value) {\r\n      isPBR = !isPBR;\r\n\r\n      if (isPBR) {\r\n        heartMesh.material = shaderMaterial;\r\n        hemiLight.intensity = hemiIntensity;\r\n        header.text = \" Use ShaderMaterial\";\r\n      } else {\r\n        heartMesh.material = originalMaterial;\r\n        hemiLight.intensity = 1;\r\n        header.text = \" Use PBRMaterial\";\r\n      }\r\n    });\r\n    panel.addControl(checkbox);\r\n\r\n    var header = new BABYLON.GUI.TextBlock();\r\n    header.text = \" Use ShaderMaterial\";\r\n    header.width = \"180px\";\r\n    header.marginLeft = \"5px\";\r\n    header.textHorizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;\r\n    header.color = \"white\";\r\n    panel.addControl(header);\r\n  });\r\n\r\n  BABYLON.ShaderMaterial.prototype.addUniformsToInspector = function (inspectableCustomProperties) {\r\n    if (this.inspectableCustomProperties) {\r\n      this.inspectableCustomProperties.push(...inspectableCustomProperties);\r\n    } else {\r\n      this.inspectableCustomProperties = inspectableCustomProperties;\r\n    }\r\n\r\n    const setValue = (property, value) => {\r\n      switch (property.type) {\r\n        case BABYLON.InspectableType.Vector2:\r\n          this.setVector2(property.propertyName, value);\r\n          break;\r\n        case BABYLON.InspectableType.Vector3:\r\n          this.setVector3(property.propertyName, value);\r\n          break;\r\n        case BABYLON.InspectableType.Quaternion:\r\n          this.setQuaternion(property.propertyName, value);\r\n          break;\r\n        case BABYLON.InspectableType.Color3:\r\n          this.setColor3(property.propertyName, value);\r\n          break;\r\n        case BABYLON.InspectableType.Slider:\r\n          this.setFloat(property.propertyName, value);\r\n          break;\r\n        case BABYLON.InspectableType.Checkbox:\r\n          this.setInt(property.propertyName, value ? 1 : 0);\r\n          break;\r\n        default:\r\n          break;\r\n      }\r\n    };\r\n\r\n    const getValue = (property) => {\r\n      switch (property.type) {\r\n        case BABYLON.InspectableType.Vector2:\r\n          return this._vectors2[property.propertyName];\r\n        case BABYLON.InspectableType.Vector3:\r\n          return this._vectors3[property.propertyName];\r\n        case BABYLON.InspectableType.Quaternion:\r\n          return this._quaternions[property.propertyName];\r\n        case BABYLON.InspectableType.Color3:\r\n          return this._colors3[property.propertyName];\r\n        case BABYLON.InspectableType.Slider:\r\n          return this._floats[property.propertyName];\r\n        case BABYLON.InspectableType.Checkbox:\r\n          return this._ints[property.propertyName] === 1;\r\n        default:\r\n          return undefined;\r\n      }\r\n    };\r\n\r\n    inspectableCustomProperties.forEach((property) => {\r\n      Object.defineProperty(this, property.propertyName, {\r\n        set: (value) => setValue(property, value),\r\n        get: () => getValue(property),\r\n        enumerable: true,\r\n        configurable: true,\r\n      });\r\n    });\r\n  };\r\n\r\n  let azimuth = 169;\r\n  let elevation = 339;\r\n\r\n  // var oldgui = document.getElementById(\"datGUI\");\r\n  // if (oldgui != null) {\r\n  //     oldgui.remove();\r\n  // }\r\n\r\n  // var gui = new dat.GUI();\r\n  // gui.domElement.style.marginTop = \"100px\";\r\n  // gui.domElement.id = \"datGUI\";\r\n  // var options = {\r\n  //     azimuth: azimuth,\r\n  //     elevation: elevation,\r\n  // }\r\n\r\n  // const GUIGroup = gui.addFolder('Bloom');\r\n  // GUIGroup.open();\r\n\r\n  // GUIGroup.add(options, \"azimuth\", 0, 360).onChange(function (value) {\r\n  //     azimuth = value;\r\n  //     updateLightDirection(azimuth, elevation);\r\n  // });\r\n  // GUIGroup.add(options, \"elevation\", 0, 360).onChange(function (value) {\r\n  //     elevation = value;\r\n  //     updateLightDirection(azimuth, elevation);\r\n  // });\r\n\r\n  const updateLightDirection = (azimuthValue, elevationValue) => {\r\n    if (dirLight) {\r\n      console.log(azimuth, elevation);\r\n      const azimuthRad = BABYLON.Tools.ToRadians(azimuthValue);\r\n      const elevationRad = BABYLON.Tools.ToRadians(elevationValue);\r\n\r\n      const x = Math.cos(elevationRad) * Math.sin(azimuthRad);\r\n      const y = Math.sin(elevationRad);\r\n      const z = Math.cos(elevationRad) * Math.cos(azimuthRad);\r\n\r\n      dirLight.direction = new BABYLON.Vector3(x, y, z).normalize();\r\n    }\r\n  };\r\n\r\n  updateLightDirection(azimuth, elevation);\r\n\r\n  return scene;\r\n}\r\n"],"names":["async","createScene","engine","canvas","BABYLON","console","clear","scene","Scene","clearColor","Color4","FromHexString","useRightHandedSystem","camera","ArcRotateCamera","Tools","ToRadians","Vector3","Zero","setTarget","alpha","beta","radius","inertia","wheelDeltaPercentage","panningSensibility","minZ","maxZ","attachControl","hemiLight","HemisphericLight","intensity","dirLight","DirectionalLight","position","fileInput","document","createElement","rootMesh","originalMaterial","shaderMaterial","type","accept","style","display","body","appendChild","isPBR","SceneLoader","ImportMeshAsync","then","result","meshes","normalizeToUnitCube","heartMesh","getChildMeshes","material","Effect","ShadersStore","ShaderMaterial","vertex","fragment","attributes","uniforms","samplers","setTexture","albedoTexture","metallicTexture","bumpTexture","setFloat","direction","registerBeforeRender","performance","now","setVector3","activeCamera","addUniformsToInspector","label","propertyName","InspectableType","Slider","min","max","step","inspectableCustomProperties","push","Button","callback","advancedTexture","GUI","AdvancedDynamicTexture","CreateFullscreenUI","panel","StackPanel","width","isVertical","horizontalAlignment","Control","HORIZONTAL_ALIGNMENT_RIGHT","verticalAlignment","VERTICAL_ALIGNMENT_CENTER","addControl","checkbox","Checkbox","height","isChecked","color","onIsCheckedChangedObservable","add","value","header","text","TextBlock","marginLeft","textHorizontalAlignment","HORIZONTAL_ALIGNMENT_LEFT","prototype","this","setValue","property","Vector2","setVector2","Quaternion","setQuaternion","Color3","setColor3","setInt","getValue","_vectors2","_vectors3","_quaternions","_colors3","_floats","_ints","forEach","Object","defineProperty","set","get","enumerable","configurable","updateLightDirection","azimuthValue","elevationValue","log","azimuthRad","elevationRad","x","Math","cos","sin","y","z","normalize"],"sourceRoot":""}