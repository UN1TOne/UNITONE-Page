{"version":3,"file":"static/js/470.d44e5f30.chunk.js","mappings":"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","sources":["babylon/spheresInteraction.js"],"sourcesContent":["// https://codepen.io/yudizsolutions/pen/jOgoamN?editors=0110\r\nexport async function createScene(engine, canvas, BABYLON) {\r\n  console.clear();\r\n  const scene = new BABYLON.Scene(engine);\r\n  scene.clearColor = new BABYLON.Color4(0.75, 0.66, 0.99, 0);\r\n\r\n  const camera = new BABYLON.ArcRotateCamera(\"camera\", Math.PI / 2, Math.PI / 3, 24, BABYLON.Vector3.Zero(), scene);\r\n  camera.attachControl(canvas, true);\r\n  camera.panningSensibility = 0;\r\n\r\n  var dirLight = new BABYLON.DirectionalLight(\"dirLight\", new BABYLON.Vector3(-1, -1, -0.5), scene);\r\n  dirLight.position = new BABYLON.Vector3(1, 1, 0.5);\r\n\r\n  var pointLight = new BABYLON.PointLight(\"pointLight\", new BABYLON.Vector3(1, 1, 1), scene);\r\n  pointLight.intensity = 0.7;\r\n\r\n  scene.onPointerMove = function (evt) {\r\n    const pickResult = scene.pick(scene.pointerX, scene.pointerY);\r\n\r\n    if (pickResult.hit && pickResult.pickedPoint) {\r\n      const targetPosition = pickResult.pickedPoint;\r\n\r\n      BABYLON.Vector3.LerpToRef(\r\n        pointLight.position,\r\n        new BABYLON.Vector3(targetPosition.x, targetPosition.y + 2, targetPosition.z),\r\n        0.1,\r\n        pointLight.position\r\n      );\r\n\r\n      const newDirection = targetPosition.subtract(dirLight.position).normalize();\r\n\r\n      BABYLON.Vector3.LerpToRef(dirLight.direction, newDirection, 0.1, dirLight.direction);\r\n    }\r\n  };\r\n\r\n  const radii = [...Array(100)].map(() => Math.random() * 0.8 + 0.2);\r\n  const positions = [...Array(100)].map(() => ({\r\n    x: (Math.random() - 0.5) * 10,\r\n    y: (Math.random() - 0.5) * 10,\r\n    z: (Math.random() - 0.5) * 10,\r\n  }));\r\n\r\n  const material = new BABYLON.PBRMaterial(\"mat\", scene);\r\n  material.metallic = 0.47;\r\n  material.roughness = 0.53;\r\n  // material.albedoColor = BABYLON.Color3.FromHexString(\"#6798ff\");\r\n  // material.emissiveColor = BABYLON.Color3.FromHexString(\"#33568d\");\r\n  material.albedoColor = new BABYLON.Color3(0.75, 0.61, 0.95);\r\n  material.emissiveColor = new BABYLON.Color3(0.57, 0.33, 0.75);\r\n\r\n  const cell = new BABYLON.CellMaterial(\"cel\", scene);\r\n  cell.diffuseColor = material.albedoColor;\r\n  cell.computeHighLevel = true;\r\n\r\n  const spheres = [];\r\n  const velocities = new Map();\r\n  const forces = new Map();\r\n\r\n  positions.forEach((pos, index) => {\r\n    const sphere = BABYLON.MeshBuilder.CreateSphere(`sphere${index}`, { diameter: radii[index] * 2 }, scene);\r\n    sphere.position.set(pos.x, -10, pos.z);\r\n    sphere.material = material;\r\n    sphere.material = cell;\r\n\r\n    sphere.metadata = { originalPosition: pos, radius: radii[index] };\r\n\r\n    spheres.push(sphere);\r\n    velocities.set(sphere.uniqueId, new BABYLON.Vector3(0, 0, 0));\r\n  });\r\n\r\n  let isSettingFinished = false;\r\n\r\n  spheres.forEach((sphere, i) => {\r\n    const { originalPosition } = sphere.metadata;\r\n\r\n    const delay = Math.random() * 500;\r\n\r\n    sphere.position.set(0, 0, 0);\r\n    sphere.scaling.set(0.1, 0.1, 0.1);\r\n\r\n    setTimeout(() => {\r\n      const scaleAnim = new BABYLON.Animation(\r\n        `scaleAnim${i}`,\r\n        \"scaling\",\r\n        60,\r\n        BABYLON.Animation.ANIMATIONTYPE_VECTOR3,\r\n        BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT\r\n      );\r\n\r\n      const scaleKeys = [\r\n        { frame: 0, value: new BABYLON.Vector3(0.1, 0.1, 0.1) },\r\n        { frame: 30, value: new BABYLON.Vector3(1.2, 1.2, 1.2) },\r\n        { frame: 60, value: new BABYLON.Vector3(1, 1, 1) },\r\n      ];\r\n      scaleAnim.setKeys(scaleKeys);\r\n\r\n      const positionAnim = new BABYLON.Animation(\r\n        `positionAnim${i}`,\r\n        \"position\",\r\n        60,\r\n        BABYLON.Animation.ANIMATIONTYPE_VECTOR3,\r\n        BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT\r\n      );\r\n\r\n      const positionKeys = [\r\n        { frame: 0, value: new BABYLON.Vector3(0, 0, 0) },\r\n        { frame: 60, value: new BABYLON.Vector3(originalPosition.x, originalPosition.y, originalPosition.z) },\r\n      ];\r\n      positionAnim.setKeys(positionKeys);\r\n\r\n      scene.beginDirectAnimation(sphere, [scaleAnim, positionAnim], 0, 60, false, 1, () => {\r\n        if (i === spheres.length - 1) {\r\n          setTimeout(() => {\r\n            isSettingFinished = true;\r\n          }, 500);\r\n        }\r\n      });\r\n    }, delay);\r\n  });\r\n\r\n  let pickedMesh;\r\n\r\n  scene.onPointerObservable.add((pointerInfo) => {\r\n    if (pointerInfo.type === BABYLON.PointerEventTypes.POINTERMOVE) {\r\n      const pickResult = scene.pick(scene.pointerX, scene.pointerY);\r\n\r\n      if (pickResult.hit && pickResult.pickedMesh && pickResult.pickedPoint) {\r\n        pickedMesh = pickResult.pickedMesh;\r\n        const forceDirection = pickResult.pickedPoint.subtract(pickedMesh.position).normalize().scale(0.3);\r\n\r\n        if (forces.has(pickedMesh.uniqueId)) {\r\n          forces.get(pickedMesh.uniqueId).addInPlace(forceDirection);\r\n        } else {\r\n          forces.set(pickedMesh.uniqueId, forceDirection);\r\n        }\r\n      }\r\n    }\r\n  });\r\n\r\n  scene.onBeforeRenderObservable.add(() => {\r\n    if (!isSettingFinished) return;\r\n\r\n    const time = performance.now() * 0.002;\r\n\r\n    for (let i = 0; i < spheres.length; i++) {\r\n      const sphereA = spheres[i];\r\n      const originalPosA = sphereA.metadata.originalPosition;\r\n      let velocityA = velocities.get(sphereA.uniqueId);\r\n\r\n      if (forces.has(sphereA.uniqueId)) {\r\n        velocityA.addInPlace(forces.get(sphereA.uniqueId));\r\n        forces.delete(sphereA.uniqueId);\r\n      }\r\n\r\n      if (sphereA !== pickedMesh) {\r\n        const offset = i * 0.2;\r\n        const breathingY = Math.sin(time + offset) * 0.1;\r\n        const breathingZ = Math.cos(time + offset) * 0.05;\r\n\r\n        sphereA.position.y = originalPosA.y + breathingY;\r\n        sphereA.position.z = originalPosA.z + breathingZ;\r\n      }\r\n\r\n      for (let j = i + 1; j < spheres.length; j++) {\r\n        const sphereB = spheres[j];\r\n        let velocityB = velocities.get(sphereB.uniqueId);\r\n\r\n        const radiusA = sphereA.metadata.radius;\r\n        const radiusB = sphereB.metadata.radius;\r\n        const minDistance = radiusA + radiusB;\r\n\r\n        const diff = sphereA.position.subtract(sphereB.position);\r\n        const distanceSquared = diff.lengthSquared();\r\n\r\n        if (distanceSquared < minDistance * minDistance) {\r\n          const pushForce = diff.normalize().scale((minDistance - Math.sqrt(distanceSquared)) * 0.1);\r\n\r\n          sphereA.position.addInPlace(pushForce);\r\n          sphereB.position.subtractInPlace(pushForce);\r\n\r\n          velocityA.addInPlace(pushForce.scale(0.2));\r\n          velocityB.subtractInPlace(pushForce.scale(0.2));\r\n\r\n          velocities.set(sphereA.uniqueId, velocityA);\r\n          velocities.set(sphereB.uniqueId, velocityB);\r\n        }\r\n      }\r\n\r\n      sphereA.position.addInPlace(velocityA);\r\n      velocityA.scaleInPlace(0.1);\r\n      velocities.set(sphereA.uniqueId, velocityA);\r\n\r\n      sphereA.position.x += (originalPosA.x - sphereA.position.x) * 0.02;\r\n      sphereA.position.y += (originalPosA.y - sphereA.position.y) * 0.02;\r\n      sphereA.position.z += (originalPosA.z - sphereA.position.z) * 0.02;\r\n    }\r\n  });\r\n\r\n  const edgeDetectionPP = new BABYLON.EdgeDetectionPostProcess(\"Edge PP\", scene, 1, camera);\r\n  edgeDetectionPP.samples = 4;\r\n  // Defines the intensity of the detected edges. Higher values result in more pronounced edges.\r\n  edgeDetectionPP.edgeIntensity = 0.3;\r\n  // Defines the width of the detected edges. Higher values result in thicker edges.\r\n  edgeDetectionPP.edgeWidth = 0.2;\r\n  // Defines the color of the detected edges\r\n  edgeDetectionPP.edgeColor = new BABYLON.Color3(0, 0, 0);\r\n\r\n  engine.setHardwareScalingLevel(0.6);\r\n\r\n  return scene;\r\n}\r\n"],"names":["async","createScene","engine","canvas","BABYLON","console","clear","scene","Scene","clearColor","Color4","camera","ArcRotateCamera","Math","PI","Vector3","Zero","attachControl","panningSensibility","dirLight","DirectionalLight","position","pointLight","PointLight","intensity","onPointerMove","evt","pickResult","pick","pointerX","pointerY","hit","pickedPoint","targetPosition","LerpToRef","x","y","z","newDirection","subtract","normalize","direction","radii","Array","map","random","positions","material","PBRMaterial","metallic","roughness","albedoColor","Color3","emissiveColor","cell","CellMaterial","diffuseColor","computeHighLevel","spheres","velocities","Map","forces","forEach","pos","index","sphere","MeshBuilder","CreateSphere","diameter","set","metadata","originalPosition","radius","push","uniqueId","pickedMesh","isSettingFinished","i","delay","scaling","setTimeout","scaleAnim","Animation","ANIMATIONTYPE_VECTOR3","ANIMATIONLOOPMODE_CONSTANT","scaleKeys","frame","value","setKeys","positionAnim","positionKeys","beginDirectAnimation","length","onPointerObservable","add","pointerInfo","type","PointerEventTypes","POINTERMOVE","forceDirection","scale","has","get","addInPlace","onBeforeRenderObservable","time","performance","now","sphereA","originalPosA","velocityA","delete","offset","breathingY","sin","breathingZ","cos","j","sphereB","velocityB","minDistance","diff","distanceSquared","lengthSquared","pushForce","sqrt","subtractInPlace","scaleInPlace","edgeDetectionPP","EdgeDetectionPostProcess","samples","edgeIntensity","edgeWidth","edgeColor","setHardwareScalingLevel"],"sourceRoot":""}