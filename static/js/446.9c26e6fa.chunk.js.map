{"version":3,"file":"static/js/446.9c26e6fa.chunk.js","mappings":"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","sources":["babylon/FPSdemo.js"],"sourcesContent":["export function createScene(engine, canvas, BABYLON) {\r\n  // console.clear();\r\n  var scene = new BABYLON.Scene(engine);\r\n  scene.useRightHandedSystem = true;\r\n\r\n  if (!BABYLON.PHYSICS) {\r\n    console.error(\"Havok Plugin is not available in BabylonScene.tsx\");\r\n  } else {\r\n    console.log(\"Using Havok from BabylonScene.tsx\", BABYLON.PHYSICS);\r\n    scene.enablePhysics(new BABYLON.Vector3(0, -9.8, 0), BABYLON.PHYSICS); // ✅ 넘겨받은 Havok 사용\r\n  }\r\n  var camera = new BABYLON.FreeCamera(\"camera1\", new BABYLON.Vector3(0, 0, 0), scene);\r\n  camera.minZ = 0.1;\r\n  camera.attachControl(canvas, true);\r\n  camera.angularSensibility = 4000;\r\n  camera.speed = 1;\r\n\r\n  var light = new BABYLON.HemisphericLight(\"light\", new BABYLON.Vector3(0, 1, 0), scene);\r\n  light.intensity = 0.7;\r\n\r\n  let createPointerLock = function (scene) {\r\n    let canvas = scene.getEngine().getRenderingCanvas();\r\n    canvas.addEventListener(\r\n      \"click\",\r\n      (event) => {\r\n        canvas.requestPointerLock =\r\n          canvas.requestPointerLock || canvas.msRequestPointerLock || canvas.mozRequestPointerLock || canvas.webkitRequestPointerLock;\r\n        if (canvas.requestPointerLock) {\r\n          canvas.requestPointerLock();\r\n        }\r\n      },\r\n      false\r\n    );\r\n  };\r\n\r\n  createPointerLock(scene);\r\n\r\n  var wall = BABYLON.MeshBuilder.CreateBox(\"wall\", { height: 4, width: 6, depth: 0.1 }, scene);\r\n  wall.position.z = 3;\r\n  const gunAnim = {\r\n    Draw: \"Arms_Draw\",\r\n    Inspect: \"Arms_Inspect\",\r\n    Idle: \"Arms_Idle\",\r\n    Walk: \"Arms_Walk\",\r\n    Run: \"Arms_Run\",\r\n    Sprint: \"Arms_Sprint\",\r\n    Fire: \"Arms_Fire\",\r\n    FullReload: \"Arms_fullreload\",\r\n    Reload: \"Arms_notfullreload\",\r\n  };\r\n  let isMouseDown = false;\r\n  let isMouseMove = false;\r\n  let shotInterval;\r\n  const shotDelay = 70;\r\n  let lastPointerX = null;\r\n  let lastPointerY = null;\r\n  const rotationSpeed = 0.0001; //  0.0025\r\n  let magazine = 30;\r\n  let isReloading = false;\r\n  let recoilAmount = 0.002;\r\n  let recoilSpeed = 0.0005;\r\n  let recoilTimer = undefined;\r\n  let originalRotationX = undefined;\r\n  let originalRotationY = undefined;\r\n  const resetRecoilAnimDuration = 60;\r\n  let currentRotationX = undefined;\r\n  let currentRotationY = undefined;\r\n  let isResetRecoil = false;\r\n  let lastMousePosition = { x: 0, y: 0 };\r\n  const movementThreshold = 100;\r\n  let elapsedSinceLastMovement = 0;\r\n  let isMovementStopped = false;\r\n  const resetRecoilAnimgGroup = new BABYLON.AnimationGroup(\"resetRotationAnimationGroup\");\r\n  let ammoText = magazine;\r\n  let gunSight;\r\n\r\n  BABYLON.SceneLoader.ImportMesh(\r\n    \"\",\r\n    \"https://raw.githubusercontent.com/AntonioToonit/Asset/master/\",\r\n    \"fps_animations_lowpoly_mp5.glb\",\r\n    scene,\r\n    (meshes, particleSystems, skeletons, animationsGroup) => {\r\n      const asset = meshes[0];\r\n      asset.setParent(camera);\r\n      asset.position = new BABYLON.Vector3(0, -1.4, -0.3);\r\n      animationsGroup.forEach((ag) => ag.stop());\r\n      const idleAnim = animationsGroup.find((ag) => ag.name === gunAnim.Idle);\r\n      idleAnim.play();\r\n      const shotAnim = animationsGroup.find((ag) => ag.name === gunAnim.Fire);\r\n      const fullReloadAnim = animationsGroup.find((ag) => ag.name === gunAnim.FullReload);\r\n      const firePoint = BABYLON.MeshBuilder.CreateBox(\"firePoint\", { size: 0.1 }, scene);\r\n      firePoint.setParent(asset.getChildMeshes(false, (m) => m.name === \"Object_7\")[0]);\r\n      firePoint.position = new BABYLON.Vector3(-0.03, 0.469, 0.642);\r\n      firePoint.setEnabled(false);\r\n      scene.onPointerObservable.add((eventData) => {\r\n        if (eventData.type === BABYLON.PointerEventTypes.POINTERMOVE) {\r\n          const currentPointerX = eventData.event.clientX;\r\n          const currentPointerY = eventData.event.clientY;\r\n          if (lastPointerX !== null && lastPointerY !== null) {\r\n            const deltaX = currentPointerX - lastPointerX;\r\n            const deltaY = currentPointerY - lastPointerY;\r\n            camera.rotation.y -= deltaX * rotationSpeed;\r\n            camera.rotation.x += deltaY * rotationSpeed;\r\n            camera.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, camera.rotation.x));\r\n          }\r\n          lastPointerX = currentPointerX;\r\n          lastPointerY = currentPointerY;\r\n          const currentMousePosition = { x: eventData.event.clientX, y: eventData.event.clientY };\r\n          const movementDetected = currentMousePosition.x !== lastMousePosition.x || currentMousePosition.y !== lastMousePosition.y;\r\n          if (movementDetected) {\r\n            lastMousePosition = currentMousePosition;\r\n            elapsedSinceLastMovement = 0;\r\n            isMovementStopped = false;\r\n          }\r\n        } else if (eventData.type === BABYLON.PointerEventTypes.POINTERUP) {\r\n          lastPointerX = null;\r\n          lastPointerY = null;\r\n        }\r\n        if (eventData.type === BABYLON.PointerEventTypes.POINTERDOWN && eventData.event.button === 0) {\r\n          isMouseDown = true;\r\n          startFire();\r\n        } else if (eventData.type === BABYLON.PointerEventTypes.POINTERUP && eventData.event.button === 0) {\r\n          isMouseDown = false;\r\n          stopFire();\r\n        }\r\n        if (!isMovementStopped) {\r\n          elapsedSinceLastMovement += scene.getEngine().getDeltaTime();\r\n          if (elapsedSinceLastMovement >= movementThreshold) {\r\n            isMovementStopped = true;\r\n          }\r\n        }\r\n      });\r\n      var projectile = BABYLON.MeshBuilder.CreateSphere(\"projectile\", { diameter: 0.2 }, scene);\r\n      projectile.isVisible = false;\r\n\r\n      var decalMaterial = new BABYLON.StandardMaterial(\"decalMat\", scene);\r\n      decalMaterial.diffuseTexture = new BABYLON.Texture(\"https://i.imgur.com/RnEDoXg.png\", scene);\r\n      decalMaterial.diffuseTexture.hasAlpha = true;\r\n      decalMaterial.useAlphaFromDiffuseTexture = true;\r\n      decalMaterial.zOffset = -2;\r\n\r\n      var isShooting = false;\r\n      let permanentName = [\"gunSight\", \"projectile\"];\r\n      let decals = [];\r\n      let decalLimit = 20;\r\n\r\n      scene.registerBeforeRender(() => {\r\n        if (isShooting) {\r\n          projectile.position.addInPlace(projectile.direction);\r\n          var pickInfo = scene.pickWithRay(new BABYLON.Ray(projectile.absolutePosition, projectile.direction), (mesh) => {\r\n            return mesh !== projectile;\r\n          });\r\n          if (pickInfo.hit) {\r\n            if (!permanentName.includes(pickInfo.pickedMesh.name)) {\r\n              var decalSize = new BABYLON.Vector3(0.1, 0.1, 0.1);\r\n              var newDecal = BABYLON.MeshBuilder.CreateDecal(\"decal\", pickInfo.pickedMesh, {\r\n                position: pickInfo.pickedPoint,\r\n                normal: pickInfo.getNormal(true),\r\n                size: decalSize,\r\n                angle: 0,\r\n              });\r\n              newDecal.material = decalMaterial;\r\n\r\n              decals.push(newDecal);\r\n\r\n              if (decals.length > decalLimit) {\r\n                decals[0].dispose();\r\n                decals.shift();\r\n              }\r\n\r\n              isShooting = false;\r\n              projectile.isVisible = false;\r\n            } else {\r\n              console.log(\"xxxx\");\r\n              setTimeout(() => {\r\n                projectile.isVisible = false;\r\n                isShooting = false;\r\n              }, 100);\r\n            }\r\n          }\r\n        }\r\n      });\r\n\r\n      function startFire() {\r\n        if (!shotInterval) {\r\n          shotInterval = setInterval(() => {\r\n            if (isMouseDown && !isReloading) {\r\n              console.log(isMouseDown, isReloading);\r\n              if (magazine > 0) {\r\n                if (!recoilTimer && originalRotationX === undefined) {\r\n                  originalRotationX = camera.rotation.x;\r\n                  originalRotationY = camera.rotation.y;\r\n                }\r\n                projectile.position = camera.position.clone();\r\n                projectile.isVisible = true;\r\n                var forward = camera.getFrontPosition(1).subtract(camera.position).normalize().scale(2); // 속도 조정\r\n                projectile.direction = forward;\r\n                isShooting = true;\r\n                if (shotAnim) {\r\n                  shotAnim.stop();\r\n                  shotAnim.play();\r\n                }\r\n                magazine--;\r\n                ammoText.text = ` ${magazine} / ∞`;\r\n                applyRecoil();\r\n              } else {\r\n                isReloading = true;\r\n                reload();\r\n              }\r\n            } else {\r\n              stopFire();\r\n            }\r\n          }, shotDelay);\r\n        }\r\n      }\r\n\r\n      function stopFire() {\r\n        clearInterval(shotInterval);\r\n        shotInterval = undefined;\r\n        if (isMovementStopped) {\r\n          isResetRecoil = true;\r\n        }\r\n      }\r\n\r\n      function reload() {\r\n        if (fullReloadAnim) {\r\n          fullReloadAnim.play();\r\n          fullReloadAnim.onAnimationGroupEndObservable.add(() => {\r\n            isReloading = false;\r\n            magazine = 30;\r\n            ammoText.text = ` ${magazine} / ∞`;\r\n          });\r\n        }\r\n      }\r\n\r\n      function applyRecoil() {\r\n        if (!recoilTimer) {\r\n          if (isMouseDown) {\r\n            isResetRecoil = false;\r\n            camera.rotation.x -= recoilAmount;\r\n            const randomRotationY = (Math.random() - 0.5) * 0.01; //  -0.005~ 0.005\r\n            camera.rotation.y += randomRotationY;\r\n            if (recoilAmount <= 0) {\r\n              clearInterval(recoilTimer);\r\n              recoilTimer = undefined;\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      function resetCameraRotation() {\r\n        if (originalRotationX !== undefined && currentRotationX === undefined) {\r\n          currentRotationX = camera.rotation.x;\r\n          currentRotationY = camera.rotation.y;\r\n          const resetRecoilXAnimation = new BABYLON.Animation(\r\n            \"resetRotationX\",\r\n            \"rotation.x\",\r\n            60,\r\n            BABYLON.Animation.ANIMATIONTYPE_FLOAT,\r\n            BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT\r\n          );\r\n          const xkeys = [\r\n            { frame: 0, value: currentRotationX },\r\n            { frame: resetRecoilAnimDuration, value: originalRotationX },\r\n          ];\r\n          resetRecoilXAnimation.setKeys(xkeys);\r\n          resetRecoilAnimgGroup.addTargetedAnimation(resetRecoilXAnimation, camera);\r\n          const resetRecoilYAnimation = new BABYLON.Animation(\r\n            \"resetRotationY\",\r\n            \"rotation.y\",\r\n            60,\r\n            BABYLON.Animation.ANIMATIONTYPE_FLOAT,\r\n            BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT\r\n          );\r\n          const ykeys = [\r\n            { frame: 0, value: currentRotationY },\r\n            { frame: resetRecoilAnimDuration, value: originalRotationY },\r\n          ];\r\n          resetRecoilYAnimation.setKeys(ykeys);\r\n          resetRecoilAnimgGroup.addTargetedAnimation(resetRecoilYAnimation, camera);\r\n          resetRecoilAnimgGroup.onAnimationGroupEndObservable.add(() => {\r\n            currentRotationX = undefined;\r\n            originalRotationX = undefined;\r\n            currentRotationY = undefined;\r\n            originalRotationY = undefined;\r\n            recoilAmount = 0.002;\r\n            isResetRecoil = false;\r\n          });\r\n          resetRecoilAnimgGroup.play();\r\n        }\r\n      }\r\n      setAmmoGUI();\r\n      scene.registerBeforeRender(() => {\r\n        if (!isResetRecoil && isMovementStopped) {\r\n          if (resetRecoilAnimgGroup) resetRecoilAnimgGroup.stop();\r\n        }\r\n      });\r\n    }\r\n  );\r\n\r\n  function setAmmoGUI() {\r\n    const advancedTexture = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI(\"UI\");\r\n    ammoText = new BABYLON.GUI.TextBlock();\r\n    ammoText.text = ` ${magazine} / ∞`;\r\n    ammoText.color = \"white\";\r\n    ammoText.fontSize = 24;\r\n    ammoText.textHorizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;\r\n    ammoText.textVerticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_BOTTOM;\r\n    ammoText.paddingBottomInPixels = 20;\r\n    advancedTexture.addControl(ammoText);\r\n  }\r\n\r\n  function addCrosshair() {\r\n    var advancedTexture = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI(\"crosshair\");\r\n    // crosshair\r\n    var crosshair_horizontal = new BABYLON.GUI.Rectangle();\r\n    crosshair_horizontal.width = \"30px\";\r\n    crosshair_horizontal.height = \"3px\";\r\n    crosshair_horizontal.background = \"green\";\r\n    crosshair_horizontal.thickness = 0;\r\n    crosshair_horizontal.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_CENTER;\r\n    crosshair_horizontal.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_CENTER;\r\n    advancedTexture.addControl(crosshair_horizontal);\r\n    var crosshair_vertical = new BABYLON.GUI.Rectangle();\r\n    crosshair_vertical.width = \"3px\";\r\n    crosshair_vertical.height = \"30px\";\r\n    crosshair_vertical.background = \"green\";\r\n    crosshair_vertical.thickness = 0;\r\n    crosshair_vertical.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_CENTER;\r\n    crosshair_vertical.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_CENTER;\r\n    advancedTexture.addControl(crosshair_vertical);\r\n    // ring type\r\n    // var ring = new BABYLON.GUI.Ellipse();\r\n    // ring.width = \"20px\";\r\n    // ring.height = \"20px\";\r\n    // ring.color = \"green\";\r\n    // ring.background = \"transparent\";\r\n    // ring.thickness = 4;\r\n    // advancedTexture.addControl(ring);\r\n  }\r\n  addCrosshair(scene);\r\n  return scene;\r\n}\r\n"],"names":["createScene","engine","canvas","BABYLON","scene","Scene","useRightHandedSystem","PHYSICS","console","log","enablePhysics","Vector3","error","camera","FreeCamera","minZ","attachControl","angularSensibility","speed","HemisphericLight","intensity","getEngine","getRenderingCanvas","addEventListener","event","requestPointerLock","msRequestPointerLock","mozRequestPointerLock","webkitRequestPointerLock","createPointerLock","MeshBuilder","CreateBox","height","width","depth","position","z","gunAnim","shotInterval","isMouseDown","lastPointerX","lastPointerY","rotationSpeed","recoilTimer","originalRotationX","originalRotationY","magazine","isReloading","recoilAmount","isResetRecoil","lastMousePosition","x","y","elapsedSinceLastMovement","isMovementStopped","resetRecoilAnimgGroup","AnimationGroup","ammoText","SceneLoader","ImportMesh","meshes","particleSystems","skeletons","animationsGroup","asset","setParent","forEach","ag","stop","find","name","play","shotAnim","fullReloadAnim","firePoint","size","getChildMeshes","m","setEnabled","onPointerObservable","add","eventData","type","PointerEventTypes","POINTERMOVE","currentPointerX","clientX","currentPointerY","clientY","deltaX","deltaY","rotation","Math","max","PI","min","currentMousePosition","POINTERUP","POINTERDOWN","button","setInterval","undefined","projectile","clone","isVisible","forward","getFrontPosition","subtract","normalize","scale","direction","isShooting","text","randomRotationY","random","clearInterval","applyRecoil","onAnimationGroupEndObservable","stopFire","getDeltaTime","CreateSphere","diameter","decalMaterial","StandardMaterial","diffuseTexture","Texture","hasAlpha","useAlphaFromDiffuseTexture","zOffset","permanentName","decals","registerBeforeRender","addInPlace","pickInfo","pickWithRay","Ray","absolutePosition","mesh","hit","includes","pickedMesh","setTimeout","decalSize","newDecal","CreateDecal","pickedPoint","normal","getNormal","angle","material","push","length","dispose","shift","advancedTexture","GUI","AdvancedDynamicTexture","CreateFullscreenUI","TextBlock","color","fontSize","textHorizontalAlignment","Control","HORIZONTAL_ALIGNMENT_LEFT","textVerticalAlignment","VERTICAL_ALIGNMENT_BOTTOM","paddingBottomInPixels","addControl","setAmmoGUI","crosshair_horizontal","Rectangle","background","thickness","horizontalAlignment","HORIZONTAL_ALIGNMENT_CENTER","verticalAlignment","VERTICAL_ALIGNMENT_CENTER","crosshair_vertical","addCrosshair"],"sourceRoot":""}