"use strict";(self.webpackChunkportfolio=self.webpackChunkportfolio||[]).push([[680],{47680:(e,t,n)=>{async function o(e,t,n){console.clear();const o=new n.Scene(e);o.clearColor=n.Color4.FromHexString("#8B3939FF"),o.useRightHandedSystem=!0;var r=new n.ArcRotateCamera("camera",n.Tools.ToRadians(90),n.Tools.ToRadians(65),10,n.Vector3.Zero(),o);r.setTarget(new n.Vector3(.07,1.14,.06)),r.alpha=1.628,r.beta=1.4,r.radius=1.6,r.inertia=.4,r.wheelDeltaPercentage=.3,r.panningSensibility=1e4,r.minZ=.01,r.maxZ=1e4,r.attachControl(t,!0);var i=new n.HemisphericLight("light",new n.Vector3(-.18,.29,.93),o);i.intensity=5;var a=new n.DirectionalLight("DirLight",new n.Vector3(.17,-.35,-.91),o);a.position=new n.Vector3(1,1,.5);var l=document.createElement("input");let s,c,m;l.type="file",l.accept=".glb",l.style.display="none",document.body.appendChild(l);let p=!0;n.SceneLoader.ImportMeshAsync("","https://raw.githubusercontent.com/UN1TOne/3DAsset/master/","human_heart.glb").then((e=>{s=e.meshes[0],s.normalizeToUnitCube(!0);const t=s.getChildMeshes(!1)[0];c=t.material,r.setTarget(t),r.alpha=1.628,r.beta=1.4,r.radius=1.6,n.Effect.ShadersStore.customPBRVertexShader="\n            precision highp float;\n\n            attribute vec3 position;\n            attribute vec3 normal;\n            attribute vec2 uv;\n\n            uniform mat4 worldViewProjection;\n            uniform mat4 world;\n            uniform float time;\n\n            varying vec3 vPosition;\n            varying vec3 vNormal;\n            varying vec2 vUV;\n\n            void main() {\n                float pulse = sin(time * 3.0) * 0.05;\n                vec3 newPosition = position + normal * pulse;\n\n                gl_Position = worldViewProjection * vec4(newPosition, 1.0);\n                vPosition = vec3(world * vec4(position, 1.0));\n                vNormal = normalize(vec3(world * vec4(normal, 0.0)));\n                vUV = uv;\n            }\n        ",n.Effect.ShadersStore.customPBRFragmentShader="\n    precision highp float;\n\n    varying vec3 vPosition;\n    varying vec3 vNormal;\n    varying vec2 vUV;\n\n    uniform vec3 lightPosition;\n    uniform vec3 lightDirection;\n    uniform vec3 hemiDirection; \n    uniform float hemiIntensity;\n    uniform vec3 cameraPosition;\n    uniform sampler2D albedoTexture;\n    uniform sampler2D metallicRoughnessTexture;\n    uniform sampler2D bumpTexture;\n    uniform float metallic;\n    uniform float roughness;\n\n    const float PI = 3.14159265359;\n\n    // Normal Distribution Function (Trowbridge-Reitz GGX)\n    float D_GGX(float NoH, float roughness) {\n        float a = roughness * roughness;\n        float a2 = a * a;\n        float NoH2 = NoH * NoH;\n        float denom = NoH2 * (a2 - 1.0) + 1.0;\n        return a2 / (PI * denom * denom);\n    }\n\n    // Geometry Function (Schlick-GGX)\n    float G_SchlickGGX(float NoV, float roughness) {\n        float r = roughness + 1.0;\n        float k = (r * r) / 8.0;\n        return NoV / (NoV * (1.0 - k) + k);\n    }\n\n    // Fresnel (Schlick \uadfc\uc0ac)\n    vec3 F_Schlick(float VoH, vec3 F0) {\n        return F0 + (1.0 - F0) * pow(1.0 - VoH, 5.0);\n    }\n\n    // Bump \ub9e4\ud551\uc73c\ub85c \ubc95\uc120 \uacc4\uc0b0\n    vec3 perturbNormal(vec3 normal, vec3 bump, vec2 uv) {\n        vec3 tangentNormal = bump * 2.0 - 1.0;\n        vec3 dPx = dFdx(vPosition);\n        vec3 dPy = dFdy(vPosition);\n        vec2 dUVx = dFdx(uv);\n        vec2 dUVy = dFdy(uv);\n\n        vec3 T = normalize(dPx * dUVy.t - dPy * dUVx.t);\n        vec3 B = normalize(cross(normal, T));\n        mat3 TBN = mat3(T, B, normal);\n\n        return normalize(TBN * tangentNormal);\n    }\n\n    void main() {\n        // \ud14d\uc2a4\ucc98 \uc0d8\ud50c\ub9c1\n        vec3 albedo = texture2D(albedoTexture, vUV).rgb;\n        vec3 metallicRoughness = texture2D(metallicRoughnessTexture, vUV).rgb;\n        vec3 bump = texture2D(bumpTexture, vUV).rgb;\n\n        // \ud14d\uc2a4\ucc98 \uac12\uacfc \uc720\ub2c8\ud3fc \uac12\uc744 \uc870\ud569\n        float texMetallic = metallicRoughness.b;\n        float texRoughness = metallicRoughness.g;\n        float finalMetallic = (metallic < 0.0) ? texMetallic : metallic;\n        float finalRoughness = (roughness < 0.0) ? texRoughness : roughness;\n\n        // Bump \ub9e4\ud551\uc73c\ub85c \ubc95\uc120 \uc870\uc815\n        vec3 N = perturbNormal(normalize(vNormal), bump, vUV);\n        vec3 V = normalize(cameraPosition - vPosition);\n\n        // 1. \uc810 \uad11\uc6d0 \ub610\ub294 \ubc29\ud5a5\uc131 \uad11\uc6d0 \uacc4\uc0b0\n        vec3 L;\n        float NoL;\n        if (length(lightDirection) > 0.0) {\n            L = normalize(-lightDirection); // \ubc29\ud5a5\uc131 \uad11\uc6d0\n            NoL = max(dot(N, L), 0.0);\n        } else {\n            L = normalize(lightPosition - vPosition); // \uc810 \uad11\uc6d0\n            NoL = max(dot(N, L), 0.0);\n        }\n\n        vec3 H = normalize(V + L);\n        float NoV = max(dot(N, V), 0.0);\n        float NoH = max(dot(N, H), 0.0);\n        float VoH = max(dot(V, H), 0.0);\n\n        // F0 \uacc4\uc0b0\n        vec3 F0 = mix(vec3(0.04), albedo, finalMetallic);\n\n        // Cook-Torrance BRDF (Specular)\n        float NDF = D_GGX(NoH, finalRoughness);\n        float G = G_SchlickGGX(NoV, finalRoughness) * G_SchlickGGX(NoL, finalRoughness);\n        vec3 F = F_Schlick(VoH, F0);\n        vec3 specular = (NDF * G * F) / (4.0 * NoV * NoL + 0.001);\n\n        // Diffuse (\uae30\uc874 \uad11\uc6d0)\n        vec3 kS = F;\n        vec3 kD = vec3(1.0) - kS;\n        kD *= 1.0 - finalMetallic;\n        vec3 diffuse = kD * albedo / PI;\n\n        // 2. HemisphericLight \uacc4\uc0b0\n        vec3 hemiL = normalize(hemiDirection);\n        float hemiNoL = max(dot(N, hemiL), 0.0); // \ubc18\uad6c\uad11 \ubc29\ud5a5\uacfc \ubc95\uc120\uc758 \uac01\ub3c4\n        vec3 hemiColor = vec3(1.0) * hemiIntensity; // \uc138\uae30\ub97c \ubc18\uc601\ud55c \ubc18\uad6c\uad11 \uc0c9\uc0c1\n        vec3 hemiDiffuse = kD * albedo / PI * hemiNoL * hemiIntensity; // \ubc18\uad6c\uad11 \uae30\uc5ec\ub3c4\n\n        // \ucd5c\uc885 \uc0c9\uc0c1 \ud569\uc0b0\n        vec3 lightColor = vec3(1.0); // \uae30\ubcf8 \uad11\uc6d0 \uc0c9\uc0c1\n        vec3 radiance = lightColor * NoL; // \uc810/\ubc29\ud5a5\uc131 \uad11\uc6d0\uc758 radiance\n        vec3 color = (diffuse + specular) * radiance + hemiDiffuse; // \ubc18\uad6c\uad11 \ucd94\uac00\n\n        // \uac10\ub9c8 \ubcf4\uc815\n        color = pow(color, vec3(1.0 / 2.2));\n\n        gl_FragColor = vec4(color, 1.0);\n    }\n",m=new n.ShaderMaterial("pbrShader",o,{vertex:"customPBR",fragment:"customPBR"},{attributes:["position","normal","uv"],uniforms:["worldViewProjection","world","view","projection","lightPosition","lightDirection","hemiDirection","hemiIntensity","cameraPosition","time","metallic","roughness"],samplers:["albedoTexture","metallicRoughnessTexture","bumpTexture"]}),m.setTexture("albedoTexture",t.material.albedoTexture),m.setTexture("metallicRoughnessTexture",t.material.metallicTexture),m.setTexture("bumpTexture",t.material.bumpTexture),m.setFloat("metallic",.07),m.setFloat("roughness",.18),a.direction=new n.Vector3(.17,-.35,-.91),o.registerBeforeRender((()=>{m.setFloat("time",.001*performance.now()),m.setVector3("cameraPosition",o.activeCamera.position),m.setVector3("lightPosition",a.position),m.setVector3("lightDirection",a.direction),m.setVector3("hemiDirection",i.direction),m.setFloat("hemiIntensity",i.intensity)})),m.addUniformsToInspector([{label:"Metallic",propertyName:"metallic",type:n.InspectableType.Slider,min:0,max:1,step:.01},{label:"Roughness",propertyName:"roughness",type:n.InspectableType.Slider,min:0,max:1,step:.01}]),t.material=m,t.inspectableCustomProperties=r.inspectableCustomProperties||[],t.inspectableCustomProperties.push({label:"Original PBRMaterial",type:n.InspectableType.Button,callback(){p?(t.material=c,i.intensity=1):(t.material=m,i.intensity=5),p=!p}});var l=n.GUI.AdvancedDynamicTexture.CreateFullscreenUI("UI"),u=new n.GUI.StackPanel;u.width="200px",u.isVertical=!1,u.horizontalAlignment=n.GUI.Control.HORIZONTAL_ALIGNMENT_RIGHT,u.verticalAlignment=n.GUI.Control.VERTICAL_ALIGNMENT_CENTER,l.addControl(u);var h=new n.GUI.Checkbox;h.width="20px",h.height="20px",h.isChecked=p,h.color="green",h.onIsCheckedChangedObservable.add((function(e){p=!p,p?(t.material=m,i.intensity=5,d.text=" Use ShaderMaterial"):(t.material=c,i.intensity=1,d.text=" Use PBRMaterial")})),u.addControl(h);var d=new n.GUI.TextBlock;d.text=" Use ShaderMaterial",d.width="180px",d.marginLeft="5px",d.textHorizontalAlignment=n.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT,d.color="white",u.addControl(d)})),n.ShaderMaterial.prototype.addUniformsToInspector=function(e){this.inspectableCustomProperties?this.inspectableCustomProperties.push(...e):this.inspectableCustomProperties=e;const t=(e,t)=>{switch(e.type){case n.InspectableType.Vector2:this.setVector2(e.propertyName,t);break;case n.InspectableType.Vector3:this.setVector3(e.propertyName,t);break;case n.InspectableType.Quaternion:this.setQuaternion(e.propertyName,t);break;case n.InspectableType.Color3:this.setColor3(e.propertyName,t);break;case n.InspectableType.Slider:this.setFloat(e.propertyName,t);break;case n.InspectableType.Checkbox:this.setInt(e.propertyName,t?1:0)}},o=e=>{switch(e.type){case n.InspectableType.Vector2:return this._vectors2[e.propertyName];case n.InspectableType.Vector3:return this._vectors3[e.propertyName];case n.InspectableType.Quaternion:return this._quaternions[e.propertyName];case n.InspectableType.Color3:return this._colors3[e.propertyName];case n.InspectableType.Slider:return this._floats[e.propertyName];case n.InspectableType.Checkbox:return 1===this._ints[e.propertyName];default:return}};e.forEach((e=>{Object.defineProperty(this,e.propertyName,{set:n=>t(e,n),get:()=>o(e),enumerable:!0,configurable:!0})}))};return((e,t)=>{if(a){console.log(169,339);const o=n.Tools.ToRadians(e),r=n.Tools.ToRadians(t),i=Math.cos(r)*Math.sin(o),l=Math.sin(r),s=Math.cos(r)*Math.cos(o);a.direction=new n.Vector3(i,l,s).normalize()}})(169,339),o}n.r(t),n.d(t,{createScene:()=>o})}}]);
//# sourceMappingURL=680.026cf88c.chunk.js.map