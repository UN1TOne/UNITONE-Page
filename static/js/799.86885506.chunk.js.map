{"version":3,"file":"static/js/799.86885506.chunk.js","mappings":"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","sources":["babylon/physicsSpheresPool.js"],"sourcesContent":["export async function createScene(engine, canvas, BABYLON) {\r\n  console.clear();\r\n\r\n  const scene = new BABYLON.Scene(engine);\r\n  scene.clearColor = BABYLON.Color4.FromHexString(\"#1726BCFF\");\r\n  scene.useRightHandedSystem = true;\r\n  scene.enablePhysics(new BABYLON.Vector3(0, -9.81, 0), new BABYLON.AmmoJSPlugin());\r\n\r\n  // let cubeTexture = new BABYLON.CubeTexture(\"textures/parking.env\", scene);\r\n  // scene.environmentTexture = cubeTexture;\r\n\r\n  const camera = new BABYLON.ArcRotateCamera(\"camera\", Math.PI / 2, Math.PI / 2, 20, new BABYLON.Vector3(0, -1.5, 0), scene);\r\n  camera.attachControl(canvas, true);\r\n  camera.lowerRadiusLimit = 20;\r\n  camera.upperRadiusLimit = 20;\r\n  camera.lowerBetaLimit = Math.PI / 2;\r\n  camera.upperBetaLimit = Math.PI / 2;\r\n  camera.lowerAlphaLimit = Math.PI / 2;\r\n  camera.upperAlphaLimit = Math.PI / 2;\r\n\r\n  const light = new BABYLON.HemisphericLight(\"light\", new BABYLON.Vector3(0, 1, 0), scene);\r\n  light.intensity = 1;\r\n\r\n  const pointLight = new BABYLON.PointLight(\"pointLight\", new BABYLON.Vector3(0, -1, 5), scene);\r\n  pointLight.intensity = 50;\r\n  pointLight.diffuse = BABYLON.Color3.FromHexString(\"#5075FF\");\r\n\r\n  const visibility_test = 0;\r\n\r\n  const ground = BABYLON.MeshBuilder.CreateGround(\"ground\", { width: 10, height: 0.1 }, scene);\r\n  ground.position.y = -10;\r\n  ground.visibility = visibility_test;\r\n  ground.physicsImpostor = new BABYLON.PhysicsImpostor(ground, BABYLON.PhysicsImpostor.BoxImpostor, { mass: 0, restitution: 0.9 }, scene);\r\n\r\n  const top = BABYLON.MeshBuilder.CreateGround(\"top\", { width: 10, height: 0.1 }, scene);\r\n  top.position.y = 10;\r\n  top.visibility = visibility_test;\r\n  top.physicsImpostor = new BABYLON.PhysicsImpostor(top, BABYLON.PhysicsImpostor.BoxImpostor, { mass: 0, restitution: 0.9 }, scene);\r\n\r\n  const createInvisibleWall = (name, position, size) => {\r\n    const wall = BABYLON.MeshBuilder.CreateBox(name, size, scene);\r\n    wall.position = position;\r\n    wall.visibility = visibility_test;\r\n    wall.isPickable = false;\r\n    wall.physicsImpostor = new BABYLON.PhysicsImpostor(wall, BABYLON.PhysicsImpostor.BoxImpostor, { mass: 0, restitution: 0.9 }, scene);\r\n    return wall;\r\n  };\r\n\r\n  createInvisibleWall(\"leftWall\", new BABYLON.Vector3(-5, 0, 0), { height: 20, width: 0.1, depth: 0.1 });\r\n  createInvisibleWall(\"rightWall\", new BABYLON.Vector3(5, 0, 0), { height: 20, width: 0.1, depth: 0.1 });\r\n\r\n  createInvisibleWall(\"frontWall\", new BABYLON.Vector3(0, 0, 0.6), { height: 20, width: 10, depth: 0.1 });\r\n  createInvisibleWall(\"backWall\", new BABYLON.Vector3(0, 0, -0.6), { height: 20, width: 10, depth: 0.1 });\r\n\r\n  const hexString = [\"#E5D9F2\", \"#CDC1FF\", \"#604CC3\"];\r\n  const blueMat = new BABYLON.PBRMaterial(\"blueMat\", scene);\r\n  blueMat.metallic = 0.9;\r\n  blueMat.roughness = 0.7;\r\n  blueMat.albedoColor = BABYLON.Color3.FromHexString(hexString[0]);\r\n  const whiteMat = new BABYLON.PBRMaterial(\"whiteMat\", scene);\r\n  whiteMat.metallic = 0.9;\r\n  whiteMat.roughness = 0.7;\r\n  whiteMat.albedoColor = BABYLON.Color3.FromHexString(hexString[1]);\r\n  const darkMat = new BABYLON.PBRMaterial(\"darkMat\", scene);\r\n  darkMat.metallic = 0.9;\r\n  darkMat.roughness = 0.7;\r\n\r\n  darkMat.albedoColor = BABYLON.Color3.FromHexString(hexString[2]);\r\n\r\n  const spheres = [];\r\n  const materials = [blueMat, whiteMat, darkMat];\r\n\r\n  for (let i = 0; i < 50; i++) {\r\n    const sphere = BABYLON.MeshBuilder.CreateSphere(`sphere${i}`, { diameter: 1 }, scene);\r\n    sphere.material = materials[Math.floor(Math.random() * materials.length)];\r\n    // sphere.visibility = 0.8;\r\n    sphere.position = new BABYLON.Vector3((Math.random() - 0.5) * 8, Math.random() * 10, 0);\r\n\r\n    sphere.physicsImpostor = new BABYLON.PhysicsImpostor(\r\n      sphere,\r\n      BABYLON.PhysicsImpostor.SphereImpostor,\r\n      { mass: 1, restitution: 0.9, friction: 0.5 },\r\n      scene\r\n    );\r\n\r\n    spheres.push(sphere);\r\n  }\r\n\r\n  const edgeDetectionPP = new BABYLON.EdgeDetectionPostProcess(\"Edge PP\", scene, 1, camera);\r\n  edgeDetectionPP.samples = 4;\r\n  edgeDetectionPP.edgeIntensity = 0.3;\r\n  edgeDetectionPP.edgeWidth = 0.2;\r\n  edgeDetectionPP.edgeColor = new BABYLON.Color3(0, 0, 0);\r\n\r\n  var defaultPipeline = new BABYLON.DefaultRenderingPipeline(\"DRPP\", true, scene, [camera]);\r\n  defaultPipeline.fxaaEnabled = true;\r\n  defaultPipeline.samples = 4;\r\n  defaultPipeline.glowLayerEnabled = true;\r\n  defaultPipeline.glowLayer.intensity = 0.75;\r\n\r\n  let selectedMesh = null;\r\n  let startingPoint = null;\r\n  let dragPlane = null;\r\n\r\n  const createDragPlane = (mesh) => {\r\n    dragPlane = new BABYLON.Plane(0, 0, 1, 0);\r\n    dragPlane.normalize();\r\n    dragPlane.origin = mesh.position;\r\n  };\r\n\r\n  const getPosition = () => {\r\n    if (!dragPlane) return null;\r\n\r\n    const ray = scene.createPickingRay(scene.pointerX, scene.pointerY, BABYLON.Matrix.Identity(), camera);\r\n\r\n    let distance = 0;\r\n    const hit = ray.intersectsPlane(dragPlane);\r\n\r\n    if (!hit) return null;\r\n\r\n    const pickedPoint = ray.origin.add(ray.direction.scale(hit));\r\n    pickedPoint.z = 0;\r\n\r\n    return pickedPoint;\r\n  };\r\n\r\n  const pointerDown = (mesh) => {\r\n    if (mesh.physicsImpostor) {\r\n      selectedMesh = mesh;\r\n      createDragPlane(mesh);\r\n      startingPoint = getPosition();\r\n\r\n      mesh.material = mesh.material.clone(\"cloned_\" + mesh.material.name);\r\n      mesh.material.albedoColor = BABYLON.Color3.White();\r\n      mesh.material.emissiveColor = new BABYLON.Color3(0.01, 0.17, 0.5);\r\n\r\n      selectedMesh.physicsImpostor.setMass(0);\r\n      selectedMesh.physicsImpostor.setLinearVelocity(BABYLON.Vector3.Zero());\r\n      selectedMesh.physicsImpostor.setAngularVelocity(BABYLON.Vector3.Zero());\r\n\r\n      scene.activeCamera.detachControl();\r\n    }\r\n  };\r\n\r\n  const pointerUp = () => {\r\n    if (selectedMesh) {\r\n      selectedMesh.physicsImpostor.setMass(1);\r\n      const originalMat = scene.materials.find((mat) => mat.name === selectedMesh.material.name.replace(\"cloned_\", \"\"));\r\n      selectedMesh.material = originalMat;\r\n\r\n      scene.activeCamera.attachControl(canvas, true);\r\n      selectedMesh = null;\r\n      startingPoint = null;\r\n      dragPlane = null;\r\n\r\n      pointLight.position = new BABYLON.Vector3(0, -1, 5);\r\n    }\r\n  };\r\n\r\n  // const pointerMove = () => {\r\n  //     if (!selectedMesh || !startingPoint) return;\r\n\r\n  //     const current = getPosition();\r\n  //     if (!current) return;\r\n\r\n  //     selectedMesh.position = current;\r\n\r\n  //     selectedMesh.physicsImpostor.setLinearVelocity(BABYLON.Vector3.Zero());\r\n  //     selectedMesh.physicsImpostor.setAngularVelocity(BABYLON.Vector3.Zero());\r\n  // };\r\n\r\n  scene.onPointerObservable.add((pointerInfo) => {\r\n    switch (pointerInfo.type) {\r\n      case BABYLON.PointerEventTypes.POINTERDOWN:\r\n        if (pointerInfo.pickInfo.hit && pointerInfo.pickInfo.pickedMesh !== ground && !pointerInfo.pickInfo.pickedMesh.isPickable === false) {\r\n          pointerDown(pointerInfo.pickInfo.pickedMesh);\r\n        }\r\n        break;\r\n      case BABYLON.PointerEventTypes.POINTERUP:\r\n        pointerUp();\r\n        break;\r\n      case BABYLON.PointerEventTypes.POINTERMOVE:\r\n        pointerMove();\r\n        break;\r\n    }\r\n  });\r\n\r\n  const limitVelocity = (mesh, maxVelocity) => {\r\n    if (mesh.physicsImpostor) {\r\n      const velocity = mesh.physicsImpostor.getLinearVelocity();\r\n      const speed = velocity.length();\r\n      if (speed > maxVelocity) {\r\n        velocity.normalize().scaleInPlace(maxVelocity);\r\n        mesh.physicsImpostor.setLinearVelocity(velocity);\r\n      }\r\n    }\r\n  };\r\n\r\n  const keepSphereInBounds = (sphere) => {\r\n    const pos = sphere.position;\r\n    if (pos.x < -5) pos.x = -4.9;\r\n    if (pos.x > 5) pos.x = 4.9;\r\n    if (pos.y < -10) pos.y = -9.9;\r\n    if (pos.y > 10) pos.y = 9.9;\r\n    if (pos.z < -0.7) pos.z = -0.6;\r\n    if (pos.z > 0.7) pos.z = 0.6;\r\n  };\r\n\r\n  const pointerMove = () => {\r\n    if (!selectedMesh || !startingPoint) return;\r\n\r\n    const current = getPosition();\r\n    if (!current) return;\r\n\r\n    const diff = current.subtract(selectedMesh.position);\r\n    const maxDragSpeed = 0.25; // 드래그 속도 제한\r\n    if (diff.length() > maxDragSpeed) {\r\n      diff.normalize().scaleInPlace(maxDragSpeed);\r\n    }\r\n    selectedMesh.position.addInPlace(diff);\r\n\r\n    selectedMesh.physicsImpostor.setLinearVelocity(BABYLON.Vector3.Zero());\r\n    selectedMesh.physicsImpostor.setAngularVelocity(BABYLON.Vector3.Zero());\r\n\r\n    pointLight.position = new BABYLON.Vector3(selectedMesh.position.x, selectedMesh.position.y, 5);\r\n  };\r\n\r\n  scene.registerBeforeRender(() => {\r\n    spheres.forEach((sphere) => {\r\n      limitVelocity(sphere, 10); // 최대 속도를 10으로 제한\r\n      keepSphereInBounds(sphere);\r\n    });\r\n  });\r\n\r\n  return scene;\r\n}\r\n"],"names":["async","createScene","engine","canvas","BABYLON","console","clear","scene","Scene","clearColor","Color4","FromHexString","useRightHandedSystem","enablePhysics","Vector3","AmmoJSPlugin","camera","ArcRotateCamera","Math","PI","attachControl","lowerRadiusLimit","upperRadiusLimit","lowerBetaLimit","upperBetaLimit","lowerAlphaLimit","upperAlphaLimit","HemisphericLight","intensity","pointLight","PointLight","diffuse","Color3","ground","MeshBuilder","CreateGround","width","height","position","y","visibility","physicsImpostor","PhysicsImpostor","BoxImpostor","mass","restitution","top","createInvisibleWall","name","size","wall","CreateBox","isPickable","depth","hexString","blueMat","PBRMaterial","metallic","roughness","albedoColor","whiteMat","darkMat","spheres","materials","i","sphere","CreateSphere","diameter","material","floor","random","length","SphereImpostor","friction","push","edgeDetectionPP","EdgeDetectionPostProcess","samples","edgeIntensity","edgeWidth","edgeColor","defaultPipeline","DefaultRenderingPipeline","fxaaEnabled","glowLayerEnabled","glowLayer","selectedMesh","startingPoint","dragPlane","getPosition","ray","createPickingRay","pointerX","pointerY","Matrix","Identity","hit","intersectsPlane","pickedPoint","origin","add","direction","scale","z","pointerDown","mesh","Plane","normalize","createDragPlane","clone","White","emissiveColor","setMass","setLinearVelocity","Zero","setAngularVelocity","activeCamera","detachControl","onPointerObservable","pointerInfo","type","PointerEventTypes","POINTERDOWN","pickInfo","pickedMesh","POINTERUP","pointerUp","originalMat","find","mat","replace","POINTERMOVE","pointerMove","current","diff","subtract","scaleInPlace","addInPlace","x","registerBeforeRender","forEach","limitVelocity","maxVelocity","velocity","getLinearVelocity","pos","keepSphereInBounds"],"sourceRoot":""}