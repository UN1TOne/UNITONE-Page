{"version":3,"file":"static/js/407.f04eaa27.chunk.js","mappings":"sGAAO,SAASA,EAAYC,EAAQC,EAAQC,GAC1CA,EAAQC,OAAOC,aAAgC,kBAAI,6TAmBnDF,EAAQC,OAAOC,aAAkC,oBAAI,8yGA4HrD,IAAIC,EAAQ,IAAIH,EAAQI,MAAMN,GAC1BO,EAAS,IAAIL,EAAQM,gBACvB,SACAN,EAAQO,MAAMC,UAAU,IACxBR,EAAQO,MAAMC,UAAU,IACxB,GACA,IAAIR,EAAQS,QAAQ,GAAI,GAAI,GAC5BN,GAEFE,EAAOK,UAAUV,EAAQS,QAAQE,QACjCN,EAAOO,gBAQK,IAAIZ,EAAQa,iBAAiB,SAAU,IAAIb,EAAQS,QAAQ,EAAG,EAAG,GAAIN,GAAjF,IAEIW,EAAS,IAAId,EAAQe,eACvB,SACAZ,EACA,CACEa,OAAQ,QACRC,SAAU,SAEZ,CACEC,WAAY,CAAC,WAAY,SAAU,MACnCC,SAAU,CAAC,QAAS,YAAa,sBAAuB,OAAQ,QAAS,iBAI7EL,EAAOM,WAAW,cAAe,IAAIpB,EAAQqB,QAAQtB,EAAOuB,MAAOvB,EAAOwB,SAE1E,IAAIC,EAASxB,EAAQyB,YAAYC,aAAa,SAAU,CAAEC,SAAU,IAAOC,MAAO,IAAOzB,GACzFqB,EAAOK,SAAWf,EAElBU,EAAOK,SAASC,iBAAkB,EAElC,IAAIC,EAAO,EAOX,OANA5B,EAAM6B,sBAAqB,KACzBD,GAAgC,KAAxBjC,EAAOmC,eACfnB,EAAOoB,SAAS,QAASH,GACzBjB,EAAOM,WAAW,cAAe,IAAIpB,EAAQqB,QAAQtB,EAAOuB,MAAOvB,EAAOwB,QAAQ,IAG7EpB,CACT,C","sources":["babylon/cloud.js"],"sourcesContent":["export function createScene(engine, canvas, BABYLON) {\r\n  BABYLON.Effect.ShadersStore[\"basicVertexShader\"] = `\r\nattribute vec3 position;\r\nattribute vec3 normal;\r\nattribute vec2 uv;\r\n\r\nuniform mat4 worldViewProjection;\r\nuniform float time;\r\n\r\nvarying vec3 vPosition;\r\nvarying vec2 vUV;\r\n\r\nvoid main() {\r\n    vec4 p = vec4(position, 1.0);\r\n    vPosition = p.xyz;\r\n    vUV = uv;\r\n    gl_Position = worldViewProjection * p;\r\n}\r\n`;\r\n\r\n  BABYLON.Effect.ShadersStore[\"basicFragmentShader\"] = `\r\nprecision highp float;\r\nuniform float iTime;\r\nuniform vec2 iResolution;\r\n\r\nvarying vec3 vPosition;\r\nvarying vec2 vUV;\r\n\r\n// --------- START-SHADER-TOY-CODE-HERE ------------\r\n\r\nconst float cloudscale = 1.1;\r\nconst float speed = 0.03;\r\nconst float clouddark = 0.5;\r\nconst float cloudlight = 0.3;\r\nconst float cloudcover = 0.2;\r\nconst float cloudalpha = 8.0;\r\nconst float skytint = 0.5;\r\nconst vec3 skycolour1 = vec3(0.2, 0.4, 0.6);\r\nconst vec3 skycolour2 = vec3(0.4, 0.7, 1.0);\r\n\r\nconst mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\r\n\r\nvec2 hash( vec2 p ) {\r\n    p = vec2(dot(p, vec2(127.1, 311.7)), dot(p, vec2(269.5, 183.3)));\r\n    return -1.0 + 2.0 * fract(sin(p) * 43758.5453123);\r\n}\r\n\r\nfloat noise( in vec2 p ) {\r\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\r\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\r\n    vec2 i = floor(p + (p.x + p.y) * K1);\r\n    vec2 a = p - i + (i.x + i.y) * K2;\r\n    vec2 o = (a.x > a.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\r\n    vec2 b = a - o + K2;\r\n    vec2 c = a - 1.0 + 2.0 * K2;\r\n    vec3 h = max(0.5 - vec3(dot(a, a), dot(b, b), dot(c, c)), 0.0);\r\n    vec3 n = h * h * h * h * vec3(dot(a, hash(i + 0.0)), dot(b, hash(i + o)), dot(c, hash(i + 1.0)));\r\n    return dot(n, vec3(70.0));\r\n}\r\n\r\nfloat fbm(vec2 n) {\r\n    float total = 0.0, amplitude = 0.1;\r\n    for (int i = 0; i < 7; i++) {\r\n        total += noise(n) * amplitude;\r\n        n = m * n;\r\n        amplitude *= 0.4;\r\n    }\r\n    return total;\r\n}\r\n\r\n// -----------------------------------------------\r\n\r\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\r\n    vec2 p = fragCoord.xy / iResolution.xy;\r\n    vec2 uv = p * vec2(iResolution.x / iResolution.y, 1.0);\r\n    float time = iTime * speed;\r\n    float q = fbm(uv * cloudscale * 0.5);\r\n\r\n    float r = 0.0;\r\n    uv *= cloudscale;\r\n    uv -= q - time;\r\n    float weight = 0.8;\r\n    for (int i = 0; i < 8; i++) {\r\n        r += abs(weight * noise(uv));\r\n        uv = m * uv + time;\r\n        weight *= 0.7;\r\n    }\r\n\r\n    float f = 0.0;\r\n    uv = p * vec2(iResolution.x / iResolution.y, 1.0);\r\n    uv *= cloudscale;\r\n    uv -= q - time;\r\n    weight = 0.7;\r\n    for (int i = 0; i < 8; i++) {\r\n        f += weight * noise(uv);\r\n        uv = m * uv + time;\r\n        weight *= 0.6;\r\n    }\r\n\r\n    f *= r + f;\r\n\r\n    float c = 0.0;\r\n    time = iTime * speed * 2.0;\r\n    uv = p * vec2(iResolution.x / iResolution.y, 1.0);\r\n    uv *= cloudscale * 2.0;\r\n    uv -= q - time;\r\n    weight = 0.4;\r\n    for (int i = 0; i < 7; i++) {\r\n        c += weight * noise(uv);\r\n        uv = m * uv + time;\r\n        weight *= 0.6;\r\n    }\r\n\r\n    float c1 = 0.0;\r\n    time = iTime * speed * 3.0;\r\n    uv = p * vec2(iResolution.x / iResolution.y, 1.0);\r\n    uv *= cloudscale * 3.0;\r\n    uv -= q - time;\r\n    weight = 0.4;\r\n    for (int i = 0; i < 7; i++) {\r\n        c1 += abs(weight * noise(uv));\r\n        uv = m * uv + time;\r\n        weight *= 0.6;\r\n    }\r\n\r\n    c += c1;\r\n\r\n    vec3 skycolour = mix(skycolour2, skycolour1, p.y);\r\n    vec3 cloudcolour = vec3(1.1, 1.1, 0.9) * clamp((clouddark + cloudlight * c), 0.0, 1.0);\r\n\r\n    f = cloudcover + cloudalpha * f * r;\r\n\r\n    vec3 result = mix(skycolour, clamp(skytint * skycolour + cloudcolour, 0.0, 1.0), clamp(f + c, 0.0, 1.0));\r\n\r\n    fragColor = vec4(result, 1.0);\r\n}\r\n\r\n// --------- END-SHADER-TOY-CODE-HERE ------------\r\n\r\nvoid main() {\r\n    mainImage(gl_FragColor, vUV * iResolution.xy);\r\n}\r\n`;\r\n\r\n  var scene = new BABYLON.Scene(engine);\r\n  var camera = new BABYLON.ArcRotateCamera(\r\n    \"camera\",\r\n    BABYLON.Tools.ToRadians(90),\r\n    BABYLON.Tools.ToRadians(65),\r\n    10,\r\n    new BABYLON.Vector3(0, -10, 0),\r\n    scene\r\n  );\r\n  camera.setTarget(BABYLON.Vector3.Zero());\r\n  camera.attachControl();\r\n\r\n  // camera.mode = BABYLON.Camera.ORTHOGRAPHIC_CAMERA;\r\n  // camera.orthoTop = 1;\r\n  // camera.orthoBottom = -1;\r\n  // camera.orthoLeft = -1;\r\n  // camera.orthoRight = 1;\r\n\r\n  var light = new BABYLON.HemisphericLight(\"light1\", new BABYLON.Vector3(0, 1, 0), scene);\r\n\r\n  var shader = new BABYLON.ShaderMaterial(\r\n    \"shader\",\r\n    scene,\r\n    {\r\n      vertex: \"basic\",\r\n      fragment: \"basic\",\r\n    },\r\n    {\r\n      attributes: [\"position\", \"normal\", \"uv\"],\r\n      uniforms: [\"world\", \"worldView\", \"worldViewProjection\", \"view\", \"iTime\", \"iResolution\"],\r\n    }\r\n  );\r\n\r\n  shader.setVector2(\"iResolution\", new BABYLON.Vector2(canvas.width, canvas.height));\r\n\r\n  var skybox = BABYLON.MeshBuilder.CreateSphere(\"sphere\", { diameter: 10000, slice: 0.5 }, scene);\r\n  skybox.material = shader;\r\n\r\n  skybox.material.backFaceCulling = false;\r\n\r\n  var time = 0;\r\n  scene.registerBeforeRender(() => {\r\n    time += engine.getDeltaTime() * 0.0001; // Adjust time increment for real-time rendering\r\n    shader.setFloat(\"iTime\", time);\r\n    shader.setVector2(\"iResolution\", new BABYLON.Vector2(canvas.width, canvas.height));\r\n  });\r\n\r\n  return scene;\r\n}\r\n"],"names":["createScene","engine","canvas","BABYLON","Effect","ShadersStore","scene","Scene","camera","ArcRotateCamera","Tools","ToRadians","Vector3","setTarget","Zero","attachControl","HemisphericLight","shader","ShaderMaterial","vertex","fragment","attributes","uniforms","setVector2","Vector2","width","height","skybox","MeshBuilder","CreateSphere","diameter","slice","material","backFaceCulling","time","registerBeforeRender","getDeltaTime","setFloat"],"sourceRoot":""}