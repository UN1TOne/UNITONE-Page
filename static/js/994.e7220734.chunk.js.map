{"version":3,"file":"static/js/994.e7220734.chunk.js","mappings":"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","sources":["babylon/dithering.js"],"sourcesContent":["export async function createScene(engine, canvas, BABYLON) {\r\n  console.clear();\r\n  const scene = new BABYLON.Scene(engine);\r\n  scene.clearColor = BABYLON.Color4.FromHexString(\"#4E6D7FFF\");\r\n\r\n  var camera = new BABYLON.ArcRotateCamera(\"camera\", BABYLON.Tools.ToRadians(90), BABYLON.Tools.ToRadians(65), 10, BABYLON.Vector3.Zero(), scene);\r\n  camera.setTarget(new BABYLON.Vector3(-0.08, 0.21, 0.07));\r\n  camera.alpha = 1.945;\r\n  camera.beta = 1.404;\r\n  camera.radius = 1.265;\r\n  camera.inertia = 0.4;\r\n  camera.wheelDeltaPercentage = 0.3;\r\n  camera.panningSensibility = 10000;\r\n  camera.minZ = 0.01;\r\n  camera.maxZ = 100;\r\n  camera.upperBetaLimit = Math.PI / 2;\r\n  camera.attachControl(canvas, true);\r\n\r\n  var light = new BABYLON.HemisphericLight(\"light\", new BABYLON.Vector3(0, 1, 0), scene);\r\n  light.intensity = 0.7;\r\n\r\n  const originalMats = [];\r\n  const ditherMats = {};\r\n\r\n  let rootMesh;\r\n\r\n  BABYLON.SceneLoader.ImportMeshAsync(\"\", \"https://raw.githubusercontent.com/UN1TOne/3DAsset/master/\", \"undead_house.glb\").then((result) => {\r\n    rootMesh = result.meshes[0];\r\n    rootMesh.normalizeToUnitCube(true);\r\n\r\n    const meshesToApplyDither = rootMesh.getChildMeshes(false, (m) => m.material);\r\n\r\n    meshesToApplyDither.forEach((m) => {\r\n      originalMats.push({ name: m.name, material: m.material });\r\n      ditherMats[m.name] = {\r\n        material: new DitherTransparencyMaterial(`ditherMaterial_${m.name}`, scene, m.material),\r\n        time: 0,\r\n      };\r\n    });\r\n\r\n    scene.registerBeforeRender(() => {\r\n      for (let mesh of meshesToApplyDither) {\r\n        mesh.computeWorldMatrix(true);\r\n        mesh.refreshBoundingInfo();\r\n\r\n        const ditherMat = ditherMats[mesh.name];\r\n        if (!ditherMat) continue;\r\n\r\n        const positions = mesh.getVerticesData(BABYLON.VertexBuffer.PositionKind);\r\n        const worldMatrix = mesh.getWorldMatrix();\r\n\r\n        if (!positions) continue;\r\n\r\n        let minDistance = Number.MAX_VALUE;\r\n\r\n        for (let i = 0; i < positions.length; i += 3) {\r\n          const vertex = BABYLON.Vector3.TransformCoordinates(new BABYLON.Vector3(positions[i], positions[i + 1], positions[i + 2]), worldMatrix);\r\n          const distance = BABYLON.Vector3.Distance(camera.position, vertex);\r\n          if (distance < minDistance) {\r\n            minDistance = distance;\r\n          }\r\n        }\r\n\r\n        if (minDistance < 0.5) {\r\n          if (!(mesh.material instanceof DitherTransparencyMaterial)) {\r\n            mesh.material = ditherMat.material;\r\n          }\r\n          ditherMat.time += scene.getEngine().getDeltaTime() / 1000;\r\n          ditherMat.material.setFloat(\"distance\", minDistance);\r\n          ditherMat.material.setFloat(\"time\", ditherMat.time);\r\n          ditherMat.material.setVector3(\"cameraPosition\", camera.position);\r\n          ditherMat.material.setMatrix(\"world\", mesh.getWorldMatrix());\r\n        } else {\r\n          const originalMat = originalMats.find((mat) => mat.name === mesh.name)?.material;\r\n          if (originalMat && mesh.material !== originalMat) {\r\n            mesh.material = originalMat;\r\n          }\r\n        }\r\n      }\r\n    });\r\n  });\r\n\r\n  class DitherTransparencyMaterial extends BABYLON.ShaderMaterial {\r\n    constructor(name, scene, originalMaterial) {\r\n      BABYLON.Effect.ShadersStore[\"ditherTransparencyVertexShader\"] = vertexShader;\r\n      BABYLON.Effect.ShadersStore[\"ditherTransparencyFragmentShader\"] = fragmentShader;\r\n\r\n      super(name, scene, \"ditherTransparency\", {\r\n        attributes: [\"position\", \"uv\"],\r\n        uniforms: [\"worldViewProjection\", \"time\", \"distance\", \"albedoColor\", \"hasTexture\", \"textureSampler\", \"baseAlpha\"],\r\n      });\r\n\r\n      this.setFloat(\"time\", 0);\r\n      this.setFloat(\"distance\", 0);\r\n\r\n      const albedoColor = originalMaterial?.albedoColor || new BABYLON.Color3(1, 1, 1);\r\n      this.setColor3(\"albedoColor\", albedoColor);\r\n\r\n      if (originalMaterial?.albedoTexture) {\r\n        this.setTexture(\"textureSampler\", originalMaterial.albedoTexture);\r\n        this.setFloat(\"hasTexture\", 1.0);\r\n      } else {\r\n        this.setFloat(\"hasTexture\", 0.0);\r\n      }\r\n\r\n      this.setFloat(\"baseAlpha\", 0.5);\r\n\r\n      this.alphaMode = BABYLON.Constants.ALPHA_COMBINE;\r\n      this.backFaceCulling = false;\r\n      this.needDepthPrePass = true;\r\n    }\r\n\r\n    needAlphaBlending() {\r\n      return true;\r\n    }\r\n\r\n    needAlphaTesting() {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  const vertexShader = `\r\n    precision highp float;\r\n    attribute vec3 position;\r\n    attribute vec2 uv;\r\n    uniform mat4 worldViewProjection;\r\n    varying vec2 vUV;\r\n\r\n    void main(void) {\r\n        gl_Position = worldViewProjection * vec4(position, 1.0);\r\n        vUV = uv;\r\n    }\r\n`;\r\n\r\n  const fragmentShader = `\r\n    precision highp float;\r\n\r\n    varying vec2 vUV;\r\n    uniform float time;\r\n    uniform float distance;\r\n    uniform vec3 albedoColor;\r\n    uniform float hasTexture;\r\n    uniform sampler2D textureSampler;\r\n    uniform float baseAlpha;\r\n\r\n    const mat4 bayerMatrix = mat4(\r\n        0.0, 8.0, 2.0, 10.0,\r\n        12.0, 4.0, 14.0, 6.0,\r\n        3.0, 11.0, 1.0, 9.0,\r\n        15.0, 7.0, 13.0, 5.0\r\n    ) / 16.0;\r\n\r\n    void main(void) {\r\n        vec2 uv = vUV;\r\n        float distanceFactor = clamp(distance / 5.0, 0.0, 1.0);\r\n        float gradient = (uv.y + sin(time + uv.x * 10.0) * 0.1) * (1.0 - distanceFactor);\r\n        ivec2 pixelCoord = ivec2(gl_FragCoord.xy);\r\n        float threshold = bayerMatrix[pixelCoord.x % 4][pixelCoord.y % 4];\r\n\r\n        float alpha = step(threshold, gradient) * baseAlpha * (1.0 - distanceFactor);\r\n\r\n        vec3 baseColor = hasTexture > 0.5 ? texture2D(textureSampler, uv).rgb : albedoColor;\r\n        gl_FragColor = vec4(baseColor, alpha);\r\n    }\r\n`;\r\n\r\n  var advancedTexture = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI(\"UI\");\r\n\r\n  var textBlock = new BABYLON.GUI.TextBlock(\"TB\");\r\n  textBlock.text = \"Zoom with scroll to see dithering :)\";\r\n  textBlock.textHorizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_CENTER;\r\n  textBlock.color = \"White\";\r\n  textBlock.outlineColor = \"Black\";\r\n  textBlock.outlineWidth = 5;\r\n  textBlock.fontSize = 25;\r\n  textBlock.height = \"30px\";\r\n  textBlock.width = \"500px\";\r\n  textBlock.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_CENTER;\r\n  textBlock.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_CENTER;\r\n\r\n  advancedTexture.addControl(textBlock);\r\n\r\n  scene.registerBeforeRender(() => {\r\n    if (camera.radius < 1.265) {\r\n      textBlock.text = \"\";\r\n    } else {\r\n      textBlock.text = \"Zoom with scroll to see dithering :)\";\r\n    }\r\n  });\r\n\r\n  return scene;\r\n}\r\n"],"names":["async","createScene","engine","canvas","BABYLON","console","clear","scene","Scene","clearColor","Color4","FromHexString","camera","ArcRotateCamera","Tools","ToRadians","Vector3","Zero","setTarget","alpha","beta","radius","inertia","wheelDeltaPercentage","panningSensibility","minZ","maxZ","upperBetaLimit","Math","PI","attachControl","HemisphericLight","intensity","originalMats","ditherMats","rootMesh","SceneLoader","ImportMeshAsync","then","result","meshes","normalizeToUnitCube","meshesToApplyDither","getChildMeshes","m","material","forEach","push","name","DitherTransparencyMaterial","time","registerBeforeRender","mesh","computeWorldMatrix","refreshBoundingInfo","ditherMat","positions","getVerticesData","VertexBuffer","PositionKind","worldMatrix","getWorldMatrix","minDistance","Number","MAX_VALUE","i","length","vertex","TransformCoordinates","distance","Distance","position","getEngine","getDeltaTime","setFloat","setVector3","setMatrix","_originalMats$find","originalMat","find","mat","ShaderMaterial","constructor","originalMaterial","Effect","ShadersStore","vertexShader","fragmentShader","super","attributes","uniforms","this","albedoColor","Color3","setColor3","albedoTexture","setTexture","alphaMode","Constants","ALPHA_COMBINE","backFaceCulling","needDepthPrePass","needAlphaBlending","needAlphaTesting","advancedTexture","GUI","AdvancedDynamicTexture","CreateFullscreenUI","textBlock","TextBlock","text","textHorizontalAlignment","Control","HORIZONTAL_ALIGNMENT_CENTER","color","outlineColor","outlineWidth","fontSize","height","width","horizontalAlignment","verticalAlignment","VERTICAL_ALIGNMENT_CENTER","addControl"],"sourceRoot":""}