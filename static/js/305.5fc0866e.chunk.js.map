{"version":3,"file":"static/js/305.5fc0866e.chunk.js","mappings":"sGAAOA,eAAeC,EAAYC,EAAQC,EAAQC,GAEhD,IAAIC,EAAQ,IAAID,EAAQE,MAAMJ,GAC9BG,EAAME,WAAaH,EAAQI,OAAOC,cAAc,aAGhD,IAAIC,EAAS,IAAIN,EAAQO,WAAW,UAAW,IAAIP,EAAQQ,QAAQ,EAAG,GAAI,IAAKP,GAG/EK,EAAOG,UAAU,IAAIT,EAAQQ,QAAQ,EAAG,EAAG,IAG3CF,EAAOI,cAAcX,GAAQ,GAGjB,IAAIC,EAAQW,iBAAiB,QAAS,IAAIX,EAAQQ,QAAQ,EAAG,EAAG,GAAIP,GAG1EW,UAAY,GAGlB,MAAMC,EAAOb,EAAQc,YAAYC,UAAU,OAAQ,CAAEC,KAAM,GAAKf,GAC1DgB,EAAOjB,EAAQc,YAAYC,UAAU,OAAQ,CAAEC,KAAM,GAAKf,GAChEY,EAAKK,SAAW,IAAIlB,EAAQQ,QAAQ,EAAG,EAAG,GAC1CS,EAAKC,SAAW,IAAIlB,EAAQQ,QAAQ,EAAG,EAAG,IAE9B,IAAIR,EAAQmB,eAClBC,aAAeH,EAmCrB,OANAhB,EAAMoB,yBAAyBC,KAAI,KA1BnBC,EAACC,EAAeC,EAAgBC,KAE9C,IAAIC,EAAU,IAAI3B,EAAQQ,QAAQ,EAAG,EAAG,GACpCoB,EAAcF,EAAKG,iBACnBC,EAAe9B,EAAQQ,QAAQuB,gBAAgBJ,EAASC,GAAaI,YAGrEC,EAAYR,EAAeS,SAASV,GAAeQ,YAGnDG,EAAMnC,EAAQQ,QAAQ4B,IAAIN,EAAcG,GAC5CE,EAAME,KAAKC,KAAK,EAAGD,KAAKE,IAAI,EAAGJ,IAC/B,IAAIK,EAAQH,KAAKI,KAAKN,GAGlBO,EAAO1C,EAAQQ,QAAQmC,MAAMb,EAAcG,GAAWD,YACtDY,EAAa5C,EAAQ6C,WAAWC,aAAaJ,EAAMF,GAGlDd,EAAKqB,qBACRrB,EAAKqB,mBAAqB/C,EAAQ6C,WAAWG,YAE/ChD,EAAQ6C,WAAWI,WAAWvB,EAAKqB,mBAAoBH,EAAY,GAAKlB,EAAKqB,mBAAmB,EAOhGxB,CAFoBV,EAAKK,SACJD,EAAKC,SACaL,EAAK,IAGvCZ,CACT,C","sources":["babylon/customLookAt.js"],"sourcesContent":["export async function createScene(engine, canvas, BABYLON) {\r\n  // This creates a basic Babylon Scene object (non-mesh)\r\n  var scene = new BABYLON.Scene(engine);\r\n  scene.clearColor = BABYLON.Color4.FromHexString(\"#7777C8FF\");\r\n\r\n  // This creates and positions a free camera (non-mesh)\r\n  var camera = new BABYLON.FreeCamera(\"camera1\", new BABYLON.Vector3(0, 5, -10), scene);\r\n\r\n  // This targets the camera to scene origin\r\n  camera.setTarget(new BABYLON.Vector3(0, 2, 0));\r\n\r\n  // This attaches the camera to the canvas\r\n  camera.attachControl(canvas, true);\r\n\r\n  // This creates a light, aiming 0,1,0 - to the sky (non-mesh)\r\n  var light = new BABYLON.HemisphericLight(\"light\", new BABYLON.Vector3(0, 1, 0), scene);\r\n\r\n  // Default intensity is 1. Let's dim the light a small amount\r\n  light.intensity = 0.7;\r\n\r\n  // 박스 두 개 생성\r\n  const box1 = BABYLON.MeshBuilder.CreateBox(\"box1\", { size: 1 }, scene);\r\n  const box2 = BABYLON.MeshBuilder.CreateBox(\"box2\", { size: 1 }, scene);\r\n  box1.position = new BABYLON.Vector3(0, 0, 0);\r\n  box2.position = new BABYLON.Vector3(2, 2, 0);\r\n\r\n  var gizmo = new BABYLON.PositionGizmo();\r\n  gizmo.attachedMesh = box2;\r\n\r\n  // 위의 IK 코드 적용\r\n  const applyIK = (startPosition, targetPosition, mesh) => {\r\n    // Forward vector 계산\r\n    let forward = new BABYLON.Vector3(0, 0, 1);\r\n    let worldMatrix = mesh.getWorldMatrix();\r\n    let forwardWorld = BABYLON.Vector3.TransformNormal(forward, worldMatrix).normalize();\r\n\r\n    // 목표 방향 계산\r\n    let direction = targetPosition.subtract(startPosition).normalize();\r\n\r\n    // 방향 간 각도 계산\r\n    let dot = BABYLON.Vector3.Dot(forwardWorld, direction);\r\n    dot = Math.max(-1, Math.min(1, dot)); // 범위를 [-1, 1]로 제한\r\n    let angle = Math.acos(dot);\r\n\r\n    // 회전 축 계산\r\n    let axis = BABYLON.Vector3.Cross(forwardWorld, direction).normalize();\r\n    let quaternion = BABYLON.Quaternion.RotationAxis(axis, angle);\r\n\r\n    // 부드럽게 회전하도록 보간\r\n    if (!mesh.rotationQuaternion) {\r\n      mesh.rotationQuaternion = BABYLON.Quaternion.Identity();\r\n    }\r\n    BABYLON.Quaternion.SlerpToRef(mesh.rotationQuaternion, quaternion, 0.1, mesh.rotationQuaternion);\r\n  };\r\n\r\n  // 애니메이션을 위한 함수\r\n  scene.onBeforeRenderObservable.add(() => {\r\n    let startPosition = box1.position;\r\n    let targetPosition = box2.position;\r\n    applyIK(startPosition, targetPosition, box1);\r\n  });\r\n\r\n  return scene;\r\n}\r\n"],"names":["async","createScene","engine","canvas","BABYLON","scene","Scene","clearColor","Color4","FromHexString","camera","FreeCamera","Vector3","setTarget","attachControl","HemisphericLight","intensity","box1","MeshBuilder","CreateBox","size","box2","position","PositionGizmo","attachedMesh","onBeforeRenderObservable","add","applyIK","startPosition","targetPosition","mesh","forward","worldMatrix","getWorldMatrix","forwardWorld","TransformNormal","normalize","direction","subtract","dot","Dot","Math","max","min","angle","acos","axis","Cross","quaternion","Quaternion","RotationAxis","rotationQuaternion","Identity","SlerpToRef"],"sourceRoot":""}